<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[HTML中的增强型表单标签]]></title>
      <url>%2F2017%2F03%2F27%2Fh5-newTitle-01%2F</url>
      <content type="text"><![CDATA[一、增型表单标签HTML5中，新标准把文本框提示信息、表单校验、日期选择控件、颜色选择控件、范围控件、进度条、标签跨表单等功能直接加入新的表单标签中。 但在众多现代浏览器中，最新版本的Opera浏览器对新型表单的支持才最为完美。 1. Number类型input标签1&lt;input type="number" name="demoNumber" min="1" max="100" step="1"/&gt; name: 标识表单提交时的key值 min: 标识当前输入框输入的最小值 max: 标识当前输入框输入的最大值 step: 标识点击增大/减小的时候，增加/减小的步长 2. Email类型input标签1&lt;input type="email" name="email" placeholder="请输入注册邮箱"/&gt; 当表单在提交前，此文本框会自动校验是否符合邮箱的正则表达式。 3. URL类型的input标签1&lt;input type="url" placeholder="请输入网址" name="url"/&gt; 4. Tel类型的input标签1&lt;input type="tel" placeholder="输入电话" name="phone"/&gt; 5. range类型的input标签1&lt;input type="range" min="0" max="50" step="5" name="rangedemo" value="0"/&gt; 此类型标签的加入，输入范围内的数据变得非常简单容易，而且非常标准，用户输入可感知体验非常好。另外此标签可以跟表单新增加的output标签一块使用，达到一个联动的效果。1234&lt;form oninput="output.value=parseInt(range.value)"/&gt; &lt;input type="range" min="0" max="100" step="5" name="range" value="0"/&gt; &lt;output name="output"&gt;0&lt;output/&gt;&lt;/form&gt; 6. 新的日期、时间、月份、星期input标签Web项目开发，一定会遇到相关的js日期控件，在HTML5中新加入的表单属性将会使Web开发变得更加简洁。1&lt;input type="date" name="datedemo"/&gt; 相关的日期属性还包括：month、time、week、datetime-local、datetime 7. 颜色选择input标签1&lt;input type=&quot;color&quot; name=&quot;colordemo&quot;/&gt; 8. input标签自动完成功能有的项目会要求实现自动完成或者输入提示功能，在HTML5的支持下将变得简单。 123456&lt;input type="text" autocomplete="on" name="demoAutoComplete" list="autoNames" /&gt;&lt;datalist id="autoNames"&gt; &lt;option value="实验楼" &gt;&lt;/option&gt; &lt;option value="HTML5" &gt;&lt;/option&gt; &lt;option value="input标签" &gt;&lt;/option&gt;&lt;/datalist&gt; 二、HTML5表单新属性1. input表单新增加的特有属性autofocus 属性，demo:1&lt;input type="text" autofocus="autofocus"/&gt; 此属性可以设置当前页面中input标签加载完毕后获得焦点。 max、min、step：这些上面介绍过，都是跟数字相关。 placeholder：提示信息属性。 multiple：用于文件上传控件，设置此属性后，允许多个文件。 校验属性：设置了required属性后预示着当前文本框在提交前必须有数据输入，而这一切都是由浏览器自动完成。还添加了pattern正则表达式校验：1&lt;input type="text" autofocus="autofocus" required pattern="\d+"/&gt; 另外一个较大的改进就是增加了form属性，也就是说，任何一个标签都可以指定它所属于一个表单，而不是必须在 中进行包裹了。1&lt;input type="text" form="demoform" name="demo"/&gt; 2. form表单新增加的属性 novalidate属性规定在提交表单时不应该验证 form 或input域 autocomplete属性规定form或input域应该拥有自动完成功能 1&lt;form action="" method="POST" novalidate="true"&gt;&lt;/form&gt; 三、综合实例12345678910111213141516171819&lt;fieldset&gt; &lt;legend&gt;表单演示：最新Opera浏览器支持效果良好&lt;/legend&gt; &lt;form action="" method="POST" id="form1" oninput="output.value=parseInt(range.value)"&gt; &lt;input type="text" autofocus="autofocus" required pattern="\d+" name="auto" placeholder="必填项测试" /&gt; &lt;input type="number" name="demoNumber" min="1" max="100" step="2" /&gt; &lt;input type="email" placeholder="请输入邮箱" name="mail" /&gt; &lt;input type="url" name="url" placeholder="输入正确的网址" /&gt; &lt;br /&gt; 日期：&lt;input type="datetime" name="time" /&gt; 颜色：&lt;input type="color" name="color" /&gt;&lt;br /&gt; &lt;br /&gt; &lt;input type="range" min="0" max="50" step="5" name="range" value="0" /&gt; &lt;output name="output"&gt;0&lt;/output&gt; &lt;br /&gt; &lt;input type="submit" value="提交表单" /&gt; &lt;/form&gt; 表单外的input标签： &lt;input type="text" form="form1" name="demo" /&gt;&lt;/fieldset&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[关于Canvas的一些参数]]></title>
      <url>%2F2017%2F03%2F27%2Fcanvas-property%2F</url>
      <content type="text"><![CDATA[一、Canvas Canvas就是一个画布，可以进行画任何的线、图形、填充等一系列的操作，而且操作的画图就是js，所以让js编程到了嗑药的地步。另外Canvas不仅仅提供简单的二维矢量绘图，也提供了三维的绘图，以及图片处理等一系列的api支持。 二、Canvas中的Context 要使用Canvas来绘制图形必须在页面中添加Canvas的标签12345&lt;canvas id="demoCanvas" width="500" height="500"&gt;&lt;p&gt; 请使用支持HTML5的浏览器查看本实例&lt;/p&gt;&lt;/canvas&gt; 只有上面的标签，只能是创建好了一个画布，其中width 和height 属性就是设置画布的大小。Id属性也是必须的，后面要用Id来拿到当前的 Canvas 的Dom对象。通过此 Canvase 的Dom对象就可以获取他的上下文 （Context） 了， Canvas 绘制图形都是靠着 Canvas 对象的上下文对象 123456&lt;script type="text/javascript"&gt;//第一步：获取canvas元素var canvasDom = document.getElementById("demoCanvas");//第二步：获取上下文var context = canvasDom.getContext('2d');&lt;/script&gt; Context上下文默认两种绘制方式： 第一种：绘制线（stroke） 第二种：填充（fill） 三、Canvas绘制立体透明矩形 1. Canvas绘制步骤： 创建HTML页面，设置画布标签 编写js，获取画布dom对象 通过canvas标签的Dom对象获取上下文 设置绘制样式、颜色 绘制矩形，或者填充矩形 12345678910111213141516171819&lt;body&gt; &lt;canvas id="demoCanvas" width="500" height="500"&gt; &lt;p&gt;请使用支持HTML5的浏览器查看本实例&lt;/p&gt; &lt;/canvas&gt; &lt;!---下面将演示一种绘制矩形的demo---&gt; &lt;script type="text/javascript"&gt; //第一步：获取canvas元素 var canvasDom = document.getElementById("demoCanvas"); //第二步：获取上下文 var context = canvasDom.getContext('2d'); //第三步：指定绘制线样式、颜色 context.strokeStyle = "red"; //第四步：绘制矩形，只有线。内容是空的 context.strokeRect(10, 10, 190, 100); //以下演示填充矩形。 context.fillStyle = "blue"; context.fillRect(110,110,100,100); &lt;/script&gt;&lt;/body&gt; 四、Canvas绘制线条 Context 对象的 beginPath 方法表示开始绘制路径，moveTo(x, y)方法设置线段的起点，lineTo(x, y)方法设置线段的终点，stroke方法用来给透明的线段着色。moveto和lineto方法可以多次使用。最后，还可以使用closePath方法，自动绘制一条当前点到起点的直线，形成一个封闭图形，省却使用一次lineto方法。123456789101112131415161718&lt;body&gt; &lt;canvas id="demoCanvas" width="500" height="600"&gt; &lt;/canvas&gt; &lt;script type="text/javascript"&gt; //通过id获得当前的Canvas对象 var canvasDom = document.getElementById("demoCanvas"); //通过Canvas Dom对象获取Context的对象 var context = canvasDom.getContext("2d"); context.beginPath(); // 开始路径绘制 context.moveTo(20, 20); // 设置路径起点，坐标为(20,20) context.lineTo(200, 200); // 绘制一条到(200,20)的直线 context.lineTo(400, 20); context.closePath(); context.lineWidth = 2.0; // 设置线宽 context.strokeStyle = "#CC0000"; // 设置线的颜色 context.stroke(); // 进行线的着色，这时整条线才变得可见 &lt;/script&gt;&lt;/body&gt; 五、Canvas绘制文本 Context上下文对象的fillText(string, x, y)方法是用来绘制文本，它的三个参数分别为文本内容、起点的x坐标、y坐标。使用之前，需用font设置字体、大小、样式（写法类似与CSS的font属性）。与此类似的还有strokeText方法，用来添加空心字。 另外注意一点：fillText方法不支持文本断行，即所有文本出现在一行内。所以，如果要生成多行文本，只有调用多次fillText方法。 123456789101112131415161718&lt;canvas id="demoCanvas" width="500" height="600"&gt;&lt;/canvas&gt;&lt;script type="text/javascript"&gt; //通过id获得当前的Canvas对象 var canvasDom = document.getElementById("demoCanvas"); //通过Canvas Dom对象获取Context的对象 var context = canvasDom.getContext("2d"); context.moveTo(200,200); // 设置字体 context.font = "Bold 50px Arial"; // 设置对齐方式 context.textAlign = "left"; // 设置填充颜色 context.fillStyle = "#005600"; // 设置字体内容，以及在画布上的位置 context.fillText("老马!", 10, 50); // 绘制空心字 context.strokeText("blog.itjeek.com!", 10, 100);&lt;/script&gt; 六、Canvas绘制圆形和椭圆 Context上下文的arc方法就是绘制圆形或者椭圆，arc方法的x和y参数是圆心坐标，radius是半径，startAngle和endAngle则是扇形的起始角度和终止角度（以弧度表示），anticlockwise表示做图时应该逆时针画（true）还是顺时针画（false）。 12345678910111213&lt;canvas id="demoCanvas" width="500" height="600"&gt;&lt;/canvas&gt;&lt;script type="text/javascript"&gt; //通过id获得当前的Canvas对象 var canvasDom = document.getElementById("demoCanvas"); //通过Canvas Dom对象获取Context的对象 var context = canvasDom.getContext("2d"); context.beginPath();//开始绘制路径 //绘制以 （60,60）为圆心，50为半径长度，从0度到360度（PI是180度），最后一个参数代表顺时针旋转。 context.arc(60, 60, 50, 0, Math.PI * 2, true); context.lineWidth = 2.0;//线的宽度 context.strokeStyle = "#000";//线的样式 context.stroke();//绘制空心的，当然如果使用fill那就是填充了。&lt;/script&gt; 七、Canvas绘制图片 Canvas绘制图片应该是他的一大特点或者是亮点吧。当然配合File的API，让JS变得无可匹敌。那接下里给大家演示一下怎样绘制图片，并且做出一个立体效果出来。123456789101112131415&lt;canvas id="demoCanvas" width="500" height="600"&gt;&lt;/canvas&gt;&lt;script type="text/javascript"&gt; //通过id获得当前的Canvas对象 var canvasDom = document.getElementById("demoCanvas"); //通过Canvas Dom对象获取Context的对象 var context = canvasDom.getContext("2d"); var image = new Image();//创建一张图片 image.src = "Images/a.png";//设置图片的路径 image.onload = function() &#123;//当图片加载完成后 for (var i = 0; i &lt; 10; i++) &#123;//输出10张照片 //参数：（1）绘制的图片 （2）坐标x，（3）坐标y context.drawImage(image, 100 + i * 80, 100 + i * 80); &#125; &#125;;&lt;/script&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HTML5中的新结构标签]]></title>
      <url>%2F2017%2F03%2F27%2Fh5-newTitle%2F</url>
      <content type="text"><![CDATA[示例图 传统 HTML5 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;my page&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;header&gt;header&lt;/header&gt; &lt;nav&gt;nav&lt;/nav&gt; &lt;article&gt; &lt;section&gt;section&lt;/section&gt; &lt;/article&gt; &lt;aside&gt;aside&lt;/aside&gt; &lt;footer&gt;footer&lt;/footer&gt; &lt;/body&gt;&lt;/html&gt; section定义文档中的节。它用来表现普通的文档内容或应用区块。但section元素标签并非一个普通的容器元素，它表示一段专题性的内容，一般会带有标题。 123456789&lt;section&gt; &lt;h1&gt;section是什么？&lt;/h1&gt; &lt;h2&gt;一个新章节&lt;/h2&gt; &lt;article&gt; &lt;h2&gt;关于section&lt;/h2&gt; &lt;p&gt;section的介绍&lt;/p&gt; ... &lt;/article&gt;&lt;/section&gt; article特殊的 section 标签，它比 section 具有更明确的语义，它代表一个独立的、完整的相关内容块。当我们描述一件具体的事物的时候，通常鼓励使用 article 来代替 section 。 article 会有标题部分（通常包含在header内），也可以包含 footer。 article 可以嵌套，内层的 article 对外层的 article 标签有隶属关系。 12345678910&lt;article&gt; &lt;header&gt; &lt;hgroup&gt; &lt;h1&gt;这是一篇介绍HTML 5结构标签的文章&lt;/h1&gt; &lt;h2&gt;HTML 5的革新&lt;/h2&gt; &lt;/hgroup&gt; &lt;time datetime="2011-03-20"&gt;2011.03.20&lt;/time&gt; &lt;/header&gt; &lt;p&gt;文章内容详情&lt;/p&gt;&lt;/article&gt; nav可以作为页面导航的链接组，其中的导航元素链接到其它页面或者当前页面的其他部分，是html代码在语义化方面更加精确，同事对于屏幕阅读器等设备的支持也更好。 1234567&lt;nav&gt; &lt;ul&gt; &lt;li&gt;厚德IT&lt;/li&gt; &lt;li&gt;FlyDragon&lt;/li&gt; &lt;li&gt;J飞龙天惊&lt;/li&gt; &lt;/ul&gt;&lt;/nav&gt; asideaside 标签用来装载非正文的内容，被视为页面里面一个单独的部分。它包含的内容与页面的主要内容是分开的，可以被删除，而不会影响到网页的内容、章节或是页面传达的信息。例如广告，成组的链接，侧边栏等等。 1234&lt;aside&gt; &lt;h1&gt;作者简介&lt;/h1&gt; &lt;p&gt;厚德IT&lt;/p&gt;&lt;/aside&gt; headerheader 标签定义文档的页眉，通常是一些引导和导航信息。它不局限于写在网页的头部，也可以写在网页的内容里面。 通常header 标签至少包含一个标记（h1 - h6 ），还可以包括hgroup 标签，还可以包括表格内容、标识、搜索表单、nav 导航等。 123456&lt;header&gt; &lt;hgroup&gt; &lt;h1&gt;网站标题&lt;/h1&gt; &lt;h1&gt;网站副标题&lt;/h1&gt; &lt;/hgroup&gt;&lt;/header&gt; footerfooter 标签定义section 或document 的页脚，包含了与页面、文章或是部分内容有关的信息，比如说文章的作者或者日期。它和header 标签使用基本一样，可以在一个页面中多次使用，如果在一个区段的后面加入footer ，那么它就相当于该区段的页脚了。123456&lt;header&gt; &lt;hgroup&gt; &lt;h1&gt;网站标题&lt;/h1&gt; &lt;h1&gt;网站副标题&lt;/h1&gt; &lt;/hgroup&gt;&lt;/header&gt; hgrouphgroup 标签是对网页或区段section 的标题元素（h1 - h6 ）进行组合。例如，在一区段中你又连续的h系列的标签元素，则可以用hgroup 将他们括起来。1234&lt;hgroup&gt; &lt;h1&gt;这是一篇介绍HTML 5结构标签的文章&lt;/h1&gt; &lt;h2&gt;HTML 5的革新&lt;/h2&gt;&lt;/hgroup&gt; fivure用于对元素进行组合。多用于图片于图片描述组合。 1234&lt;figure&gt; &lt;img src="img.gif" alt="figure标签" title="figure标签" /&gt; &lt;figcaption&gt;这儿是图片的描述信息&lt;/figcaption&gt;&lt;/figure&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Ajax学习小记-概念]]></title>
      <url>%2F2017%2F03%2F27%2Fajax-note%2F</url>
      <content type="text"><![CDATA[异步通过 XMLHttpRequest 函数来实现客户端和服务器端的异步处理 具体实现： 运用HTML和CSS来实现页面，表达信息； 运用XMLHttpRequest和Web服务器进行数据的异步交换； 运用JavaScript操作DOM，实现动态局部刷新； XMLHttpREquest对象 不兼容IE6123456var request;if (window.XMLHttpRequest) &#123; request = new XMLHttprequest();//IE7+,chrome,ff,safari.&#125; else &#123; request = new ActiveXobject('Microsoft.XmlHTTP');??&#125; HTTP请求HTTP请求过程 建立TCP连接 Web浏览器向Web服务器发送请求命令 Web浏览器发送请求头信息 Web服务器应答 Web服务器发送应答头信息 Web服务器向浏览器发送数据 Web服务器关闭TCP连接 HTTP组成部分 HTTP请求的方法或动作，比如是GET还是POST请求 正在请求的URL 请求头（如客户端环境信息，身份验证信息） 请求体，也就是请求 正文，请求好着呢个文中可以包含客户提交的 查询字符串信息，表单信息等等。 重点概念 GET： 一般用信息获取 使用URL传递参数 对所发送信息的数量也有 POST： 一半用于修改服务器上的资源 对所发送的信息数量无限制 响应组成： 数字文字的状态码，显示请求的成功和失败 响应头 响应体 HTTP状态码 1XX：信息类，表示收到浏览器请求，正在处理 2XX: 成功，正确接受 3XX：重定向，请求失败 4XX：客户端错误，如 404 NOT 5XX：服务器错误，如 500 XMLHttpRequest发送请求： open(method,url,async) method：规定HTTP发送请求的方式是get还是post,不区分大小写，一般来说用大写 url：请求地址(相对地址或绝对地址) async:同步/异步(false/true)，默认是异步也就是true，可以不用填写 send(string): 发送到服务器（该参数可以填或者不填—–get方法不填或填null，post:一般要填） XMLHttpRequest取得响应 responseText:获得字符串形式的响应数据 responseXML：获得XML形式的响应数据（比较少） status和statusText:以数字和文本形式返回HTTP状态码 getAllResponseHeader()：获取所有的响应报头 getResponseHeader()：查询响应中的某个字段的值 readyState属性的变化代表服务器响应的变化 请求未初始化，open还没有调用 服务器连接已建立，open已经调用了 请求已接收，也就是接收到头信息了 请求处理中，也就是接收到了响应主体 请求已完成，且响应已就绪，也就是响应完成了]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[慕课网-人机大战五子棋AI篇学习笔记]]></title>
      <url>%2F2017%2F03%2F27%2Fgo-bang%2F</url>
      <content type="text"><![CDATA[创建赢法数组 先贴出第一步代码 1234567var wins = [];for(let i=0 ; i &lt; 15 ; i++ ) &#123; wins[i] = []; for(let j = 0; j&lt;15; j++) &#123; wins[i][j] = []; &#125;&#125; 这段代码仅仅只是创了一个准备用于记录所有赢法的三维空数组。 接下来第二部就是建立赢法数组，复制并建立索引。代码：竖排123456789var count = 0;for(let i=0; i&lt; 15 ;i++) &#123; for(let j=0;j&lt;11 ;j++) &#123; for(let k=0;k&lt;5;k++) &#123; wins[i][j+k][count] = true; &#125; count++; &#125;&#125; 本段代码的含义就是遍历了所有竖排列中存在的赢的组合，count为每一种赢法所对应的唯一索引。例如：12345wins[0][0][0] = true;wins[0][1][0] = true;wins[0][2][0] = true;wins[0][3][0] = true;wins[0][4][0] = true; 就是意味着我们将第一竖排前五个空格连成一线的赢法都列举出来，并给每一个格子赋值为true、给出的索引为count = 0（即第三维数组）。 同理，很容易可以写出遍历横排，45°角和135°角排列上的代码： 横排12345678910var count = 0;for(let i=0; i&lt; 15 ;i++) &#123; for(let j=0;j&lt;11 ;j++) &#123; for(let k=0;k&lt;5;k++) &#123; wins[j+k][i][count] = true; &#125; count++; &#125;&#125; 45°12345678910var count = 0;for(let i=0; i&lt; 11 ;i++) &#123; for(let j=0;j&lt;11 ;j++) &#123; for(let k=0;k&lt;5;k++) &#123; wins[i+k][j+k][count] = true; &#125; count++; &#125;&#125; 135°12345678910var count = 0;for(let i=0; i&lt; 11 ;i++) &#123; for(let j=14;j&gt;3 ;j++) &#123; for(let k=0;k&lt;5;k++) &#123; wins[i+k][j-k][count] = true; &#125; count++; &#125;&#125; 相较于较为抽象的描述，还是图来的简单明了。 输赢判断慕课网将其称为赢法统计，我总觉得过于抽象了。让我来理解，说是输赢判断，或者说是迈向胜利的进度，更加容易理解。代码：1234567var myWin = [];//我方胜利进度（黑子）var coumputerWin = [];//电脑方胜利进度(白子)for(let i = 0;i &lt; count ; i++) &#123; myWin[i] = 0; coumputerWin[i] = 0;&#125; 首相遍历count，两方胜利进度数组都赋值为0。 然后就要修改落子时的onclick事件的判定条件。12345678910111213141516171819202122232425262728293031var over = false;//判断棋局是否结束chess.onclick = function(e) &#123; if(over) &#123; return; &#125; var x = e.offsetX; var y = e.offsetY; var i= Math.floor(x/30); var j = Math.floor(y/30); if(hascheer[i][j] == 0) &#123; oneStep(i,j,me); if(me) &#123; hascheer[i][j] = 1; &#125;else &#123; hascheer[i][j] = 2; &#125; me = !me; //本次操作添加代码 for(let k= 0;k&lt;count; k++) &#123; if(wins[i][j][k]) &#123; myWin[k] ++; pcWin = 6;//当有一方占据了当前赢法数组中的一格，即可判定为另一方在该赢法数组条件下已不可能获胜，抛出异常数值。 if(myWin[k] == 5) &#123; window.alert(&quot;你赢了!&quot;); &#125; &#125; &#125; &#125;&#125; 前面的代码是UI篇当中的。关于输赢判断，思路是在onclick事件下，每次落子，遍历count,并对落子坐标i,j所对应的赢法k胜利进度+1，胜利进度=5的时候，就代表在这一赢法下获胜了。 例如，在wins[0][0][k]的情况下，其实只有三种赢法，即向右五格，向下五格以及45°角五格，因此，当k不等于这三种赢法的索引时，myWins[k]就不会自加，即该赢法进度没有变化。PS：后面要做computer自动下子，所以这里只写了黑子的判定。 AI实现代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100var pcAI = function() &#123; //玩家分数 let myScore = [],// 电脑分数 pcScore = [],// 最优位置的分数 max = 0,// 电脑预落子maxI列 maxI = 0,// 电脑预落子maxJ行 maxJ =0; for (let i=0;i&lt;15;i++) &#123; myScore[i] = []; pcScore[i] = []; for(let j=0; j&lt;15;j++) &#123; myScore[i][j] = 0; pcScore[i][j] = 0; &#125; &#125;// 对两个数组分别进行加分 for (let i=0;i&lt;15;i++) &#123; for(let j=0;j&lt;15;j++) &#123; if(hasChess[i][j] == 0) &#123; for (let k=0;k&lt;count;k++)&#123; if(wins[i][j][k]) &#123; switch(myWin[k]) &#123; case 1: myScore[i][j] +=200; break; case 2: myScore[i][j] +=400; break; case 3: myScore[i][j] +=2000; break; case 4: myScore[i][j] +=10000; break; default: break; &#125; switch(pcWin[k]) &#123; case 1: pcScore[i][j] +=220; break; case 2: pcScore[i][j] +=420; break; case 3: pcScore[i][j] +=2220; break; case 4: pcScore[i][j] +=20000; break; case 6: pcScore[i][j] = 0; break; default: break; &#125; &#125; &#125;// 若玩家在(i,j)处的分数高于目前的最高分数,则落子在(i,j)处 if(myScore[i][j] &gt; max) &#123; max = myScore[i][j]; maxI = i; maxJ = j; &#125;else if(myScore[i][j] == max&amp;&amp; pcScore[i][j] &gt; pcScore[maxI][maxJ])&#123; // 如果玩家(i,j)处和目前最优分数一样大，则比较电脑在该位置和预落子的位置的分数 maxI = i; maxJ = j; &#125;// 如果电脑(i,j)处比目前最优的分数大，则落子在(i,j)处 if(pcScore[i][j] &gt; max) &#123; max = pcScore[i][j]; maxI = i; maxJ = j; &#125;else if(pcScore[i][j] == max &amp;&amp; myScore[i][j] &gt; myScore[maxI][maxJ])&#123;// 如果电脑(i,j)处和目前最优分数一样大，则比较玩家在该位置和预落子的位置的分数 maxI = i; maxJ = j; &#125; &#125; &#125;; &#125; oneStep(maxI,maxJ,false); hasChess[maxI][maxJ] = 2; for (let n=0 ; n&lt;count;n++) &#123; if(wins[maxI][maxJ][n]) &#123; pcWin[n]++; myWin[n] =6; if(pcWin[n] == 5) &#123; window.alert("你输了！"); over = true; &#125; &#125; &#125;&#125; 很复杂的代码。通过遍历坐标，确定包含这个坐标的赢法，然后对这个赢法进行权重加成，赢法内拥有越多的黑子，权重越大。同时，对自己下子的每个坐标所对应的的赢法也进行加权，并且电脑获胜是的权重是高于人的。（这里很难用自己的话描述出来）。以图为例： 当黑子落点为坐标[0][0]时，此时应当是有三个方向上，即横、竖、45°，三个赢法数组存在。并且所对应的元素均为true。黑子落点后，上面代码中的第一次循环因为if(hasCheer[0][0])为false，跳过，三种赢法内空余的格子都进入循环，每种myWin[k]都是一，所以横、竖、45°线上其他空格的分数均为200，因此第一次循环获取到坐标i=0,j=之后，后面的因为都与它相等不会获得更高权重，所以AI会落子在0,1处。 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231//canvasvar gobang = document.getElementById("gobang"), context = gobang.getContext("2d"), background = new Image(); background.src = "img/bg.png";context.strokeStyle = "#000";background.onload = function() &#123; context.drawImage(background,0,0,450,450); (() =&gt; &#123; for (let i= 0; i&lt;15 ; i++ ) &#123; context.moveTo(15 + i*30, 15); context.lineTo(15 + i*30, 435); context.stroke(); context.moveTo(15,15 + i*30); context.lineTo(435,15+ i*30); context.stroke(); &#125; &#125;)();&#125;//落子var hasChess = [], me = true;for (let i=0; i&lt;15; i++) &#123; hasChess[i] = []; for (let j=0; j&lt;15;j++) &#123; hasChess[i][j] = 0; &#125;&#125;var oneStep = function (i,j,me) &#123; context.beginPath(); context.arc(15 + i*30,15 + j*30,13,0,2*Math.PI); context.closePath(); let gradient = context.createRadialGradient(15 + i*30, 15+ j*30 -2,50,15 + i*30 +2, 15+j * 30 - 2,0); me ? (()=&gt;&#123;gradient.addColorStop(0,"#0a0a0a");gradient.addColorStop(1,"#8e8e8e" )&#125;)() : (()=&gt;&#123;gradient.addColorStop(0,"#8e8e8e");gradient.addColorStop(1,"#fff")&#125;)(); context.fillStyle = gradient; context.fill(); me = !me;&#125;//赢法数组var wins = [], count = 0; //生产赢法数组for (let i=0;i&lt;15 ; i ++) &#123; wins[i] = []; for(let j = 0; j&lt;15;j ++) &#123; wins[i][j] = []; &#125;&#125;//所有竖排赢法for (let i=0; i&lt;15; i++) &#123; for(let j=0;j&lt;11;j++) &#123; for (let k=0;k&lt;5;k++) &#123; wins[i][j+k][count] = true; &#125; count++; &#125;&#125;//所有横排赢法for (let i=0; i&lt;15;i++) &#123; for (let j = 0;j&lt;11;j ++) &#123; for (let k=0;k&lt;5;k++) &#123; wins[j+k][i][count] = true; &#125; count++; &#125;&#125;//所有45°赢法for (let i=0;i&lt;11;i++) &#123; for(let j=0;j&lt;11;j++) &#123; for(let k=0;k&lt;5;k++) &#123; wins[i+k][j+k][count] = true; &#125; count++; &#125;&#125;//所有135°赢法for (let i=0; i&lt;11;i++) &#123; for(let j=14;j&gt;3;j--) &#123; for (let k=0;k&lt;5;k++) &#123; wins[i+k][j-k][count] = true; &#125; count++; &#125;&#125;//输赢判断var myWin = [], pcWin = [], over = false;for(let i=0;i&lt;count ;i++) &#123; myWin[i] = 0; pcWin[i] = 0;&#125;//AI实现var pcAI = function() &#123; //玩家分数 let myScore = [],// 电脑分数 pcScore = [],// 最优位置的分数 max = 0,// 电脑预落子maxI列 maxI = 0,// 电脑预落子maxJ行 maxJ =0; for (let i=0;i&lt;15;i++) &#123; myScore[i] = []; pcScore[i] = []; for(let j=0; j&lt;15;j++) &#123; myScore[i][j] = 0; pcScore[i][j] = 0; &#125; &#125;// 对两个数组分别进行加分 for (let i=0;i&lt;15;i++) &#123; for(let j=0;j&lt;15;j++) &#123; if(hasChess[i][j] == 0) &#123; for (let k=0;k&lt;count;k++)&#123; if(wins[i][j][k]) &#123; switch(myWin[k]) &#123; case 1: myScore[i][j] +=200; break; case 2: myScore[i][j] +=400; break; case 3: myScore[i][j] +=2000; break; case 4: myScore[i][j] +=10000; break; default: break; &#125; switch(pcWin[k]) &#123; case 1: pcScore[i][j] +=220; break; case 2: pcScore[i][j] +=420; break; case 3: pcScore[i][j] +=2220; break; case 4: pcScore[i][j] +=20000; break; case 6: pcScore[i][j] = 0; break; default: break; &#125; &#125; &#125;// 若玩家在(i,j)处的分数高于目前的最高分数,则落子在(i,j)处 if(myScore[i][j] &gt; max) &#123; max = myScore[i][j]; maxI = i; maxJ = j; &#125;else if(myScore[i][j] == max&amp;&amp; pcScore[i][j] &gt; pcScore[maxI][maxJ])&#123; // 如果玩家(i,j)处和目前最优分数一样大，则比较电脑在该位置和预落子的位置的分数 maxI = i; maxJ = j; &#125;// 如果电脑(i,j)处比目前最优的分数大，则落子在(i,j)处 if(pcScore[i][j] &gt; max) &#123; max = pcScore[i][j]; maxI = i; maxJ = j; &#125;else if(pcScore[i][j] == max &amp;&amp; myScore[i][j] &gt; myScore[maxI][maxJ])&#123;// 如果电脑(i,j)处和目前最优分数一样大，则比较玩家在该位置和预落子的位置的分数 maxI = i; maxJ = j; &#125; &#125; &#125;; &#125; oneStep(maxI,maxJ,false); hasChess[maxI][maxJ] = 2; for (let n=0 ; n&lt;count;n++) &#123; if(wins[maxI][maxJ][n]) &#123; pcWin[n]++; myWin[n] =6; if(pcWin[n] == 5) &#123; window.alert("你输了！"); over = true; &#125; &#125; &#125;&#125;gobang.onclick = function(e) &#123; if (over) &#123; return; &#125; if (!me) &#123; return; &#125; let x = e.offsetX, y = e.offsetY, i = Math.floor(x/30), j = Math.floor(y/30); if (hasChess[i][j] == 0 ) &#123; oneStep(i,j,me); hasChess[i][j] = 1; for (let k=0; k&lt;count;k++) &#123; if(wins[i][j][k]) &#123; myWin[k]++; pcWin[k] =6; if(myWin[k] == 5) &#123; window.alert("你赢了！"); over = true; &#125; &#125; &#125; if(!over) &#123; pcAI(); &#125; &#125;&#125;]]></content>
    </entry>

    
  
  
</search>
