<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[async-await-parallel]]></title>
    <url>%2F2017%2F06%2F30%2Fasync-await-parallel%2F</url>
    <content type="text"><![CDATA[最近学习 Node.JS,很多教程都是在 Node 早期版本发布的，控制并发的手段大多使用 eventproxy,或者是一些其他的第三方库类似于bluebird,async。而 Node.JS 早已实现对原生async/await 的支持，而且我学习的框架是 koa2，也是使用async/await的一个框架。为了避免语法混乱，我希望有一个使用async/await的并发控制模块。 async-await-parallel很简单的一个模块，本质是一个Promise 的队列函数，我还没有读懂源码，但是它的语法是asycn/await，没有更多的api，非常简单易用的一个模块。用法：123456789const parallel = require(&apos;async-await-parallel&apos;)await parallel([ async () =&gt; &#123; ... &#125;, async () =&gt; &#123; ... &#125;, async () =&gt; &#123; ... &#125;, async () =&gt; &#123; ... &#125;, async () =&gt; &#123; ... &#125;,], 2) 就是这么简单，第一个参数是 async 函数数组，第二个参数是并发数 源代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182async function parallelMap (thunks, concurrency = 5) &#123; if (concurrency &gt; 0) &#123; concurrency = Math.min(concurrency, thunks.length) &#125; else &#123; concurrency = thunks.length &#125; let index = 0 let results = [ ] await parallelPool(concurrency, async () =&gt; &#123; if (index &lt; thunks.length) &#123; const currentIndex = index++ const thunk = thunks[currentIndex] results[currentIndex] = await thunk.call(this) &#125; return (index &lt; thunks.length) &#125;) return results&#125;/** * Executes a given async `task` multiple times in parallel with a guaranteed * max concurrency given by `size`. * * The task should be an async function which resolves to a boolean for whether * or not there are more tasks to process. * * If any single task fails (eg, returns a rejected Promise), the pool will drain * any remaining active tasks and reject the resulting Promsie. * * @param &#123;Number&#125; size * @param &#123;async Function(Void) =&gt; Boolean&#125; task * * @return &#123;Promise&lt;Void&gt;&#125; */async function parallelPool (size, task) &#123; let done = false let active = 0 let errors = [ ] return new Promise((resolve, reject) =&gt; &#123; function poolIterator () &#123; while (active &lt; size &amp;&amp; !done) &#123; active++ task() .then((more) =&gt; &#123; if (--active &lt;= 0 &amp;&amp; (done || !more)) &#123; if (errors.length &gt; 0) &#123; // at least one task failed return reject(new Error(errors)) &#125; else &#123; // all tasks completed successfully return resolve() &#125; &#125; else if (more) &#123; poolIterator() &#125; else &#123; done = true &#125; &#125;) .catch((err) =&gt; &#123; errors.push(err) done = true if (--active &lt;= 0) &#123; return reject(new Error(errors)) &#125; else &#123; // wait until all active tasks are drained before rejecting the // final result (no new tasks will be started now that we're in // this error state) &#125; &#125;) &#125; &#125; poolIterator() &#125;)&#125;]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[给初学者的 JavaScript Promise 教程 | Scotch]]></title>
    <url>%2F2017%2F05%2F28%2Fes6-promise%2F</url>
    <content type="text"><![CDATA[本文转载自：众成翻译译者：cherryvenus链接：http://www.zcfy.cc/article/1961原文：https://scotch.io/tutorials/javascript-promises-for-dummies Javascript Promises 不难。然而，许多人刚开始接触这个概念的时候，觉得有些难以理解。因此，我写下了我是如何理解 Promise 的，用一个通俗易懂的方法。 理解 PromisePromise 简介: “假设你是一个宝宝. 你的妈妈承诺（Promise）你，下个礼拜她会给你一台新手机。” 你不知道，下个礼拜你是否会拿到手机。你的妈妈可以真的给你买一个全新的手机，或者放你鸽子，也有可能如果她不开心:(了就扣下了手机。 这个就是承诺（Promise）。一个 Promise 有3个状态。他们分别是： Promise 是待定的（pending）： 你不知道你下个礼拜能不能拿到手机。 Promise 是已解决的（resolved）：你的妈妈真的给你买了一个全新的手机。 Promise 是被拒绝的（rejected）: 因为你妈妈不开心所以不给你手机了。 创建一个 Promise让我们将这个转化为 JavaScript。 123456789101112131415161718/* ES5 */var isMomHappy = false;// Promisevar willIGetNewPhone = new Promise( function (resolve, reject) &#123; if (isMomHappy) &#123; var phone = &#123; brand: &apos;Samsung&apos;, color: &apos;black&apos; &#125;; resolve(phone); // 完成了 &#125; else &#123; var reason = new Error(&apos;妈妈不开心&apos;); reject(reason); // reject &#125; &#125;); 代码本身颇具表现力。 我们用一个布尔值 isMomHappy，来定义妈妈是否开心。 我们有一个命名为willIGetNewPhone的 Promise 。这个 Promise 可以是 已完成的（resolved） （如果妈妈给你买了一个新手机）或者 被拒绝的（rejected） （妈妈不开心，她没有给你买一个）。 这里有一个标准的语法来新建一个 Promise，参考MDN 文档，一个 promise 语法看上去像这样。 12// promise 语法看上去像这样new Promise(/* executor*/ function (resolve, reject) &#123; ... &#125; ); 你需要记住的是，当结果是正确的，在你的 promise 中调用 resolve(正确的值)。在我们的例子中，如果妈妈很开心，我们就会拿到手机。因此，我们调用 resolve 函数和 phone 这个变量。如果我们的妈妈不开心，我们会调用 reject 函数和一个理由（reason）reject(reason)； 使用 Promise现在，我们有一个 Promise。来看看怎么使用它： 1234567891011121314151617/* ES5 */...// 调用我们的 Promisevar askMom = function () &#123; willIGetNewPhone .then(function (fulfilled) &#123; // 太好啦, 你获得了一个新手机 console.log(fulfilled); // output: &#123; brand: &apos;Samsung&apos;, color: &apos;black&apos; &#125; &#125;) .catch(function (error) &#123; // 好不幸，你妈妈没买手机 console.log(error.message); // output: &apos;妈妈不开心&apos; &#125;);&#125;;askMom(); 我们有一个名为 askMom 的函数。在这个函数中，我们会使用 Promise willIGetNewPhone。 一旦 Promise 被解决（resolved）或者被拒（rejected），我门希望采取些措施。我们用 .then 和 .catch 来实现。 在我们的例子中，.then 之中有个 function(fulfilled) { ... } 。fulfilled 是什么？fulfilled 就是是你传入 Promise 的 resolve(your_success_value).因此，在我们例子中就是 phone。 我们在 .catch 中有 function(error){ ... }。error 是什么？正如你猜测的，error 正是你传入 Promise 中的 reject(your_fail_value) 。因此，在我们的例子中就是 reason。 让我们看看例子运行之后的结果吧！ Demo: https://jsbin.com/nifocu/1/edit?js,console 串联 PromisePromiss 是可串联的。 也就是说，你，宝宝，承诺（Promise）你的小伙伴，当你妈妈给你买了手机，你就会给他们看新手机。 这就是另一个 Promise 啦。我们来写一个！ 123456789101112// 简略...// 第二个 promisevar showOff = function (phone) &#123; return new Promise( function (resolve, reject) &#123; var message = &apos;hey 伙计，我有个新 &apos; + phone.color + &apos; &apos; + phone.brand + &apos;手机&apos;; resolve(message); &#125; );&#125;; 说明: 在这个例子中，你可能意识到我们没有调用 reject。因为这个是可选的参数。 我们可以简化这个样例就像用 Promise.resolve 代替。 123456789// 简略...// 第二个 promisevar showOff = function (phone) &#123; var message = &apos;hey 伙计，我有个新 &apos; + phone.color + &apos; &apos; + phone.brand + &apos; 手机&apos;; return Promise.resolve(message);&#125;; 让我们串联 Promise。你，宝宝只能在willIGetNewPhone Promise 实现之后，才能开始 showOff Promise。 123456789101112131415...// 调用 Promisevar askMom = function () &#123; willIGetNewPhone .then(showOff) // 在这里串联 .then(function (fulfilled) &#123; console.log(fulfilled); // output: &apos;Hey 伙计, 我有一个新的黑色三星手机。&apos; &#125;) .catch(function (error) &#123; // 好不幸，你妈妈没买手机 console.log(error.message); // output: &apos;妈妈不开心&apos; &#125;);&#125;; 串联 Promise 简单吧！ Promises 是异步的Promise 是异步的。让我们在调用 Promise 之前和之后各打印一个信息。 12345678910111213// 调用我们的Ppromisevar askMom = function () &#123; console.log(&apos;询问妈妈之前&apos;); // 运行之前打印 willIGetNewPhone .then(showOff) .then(function (fulfilled) &#123; console.log(fulfilled); &#125;) .catch(function (error) &#123; console.log(error.message); &#125;); console.log(&apos;询问妈妈之后&apos;); // 运行之后打印&#125; 预计的输出序列是怎么样的？也许你预计是这样的 1231\. 询问妈妈之前2\. Hey 伙计, 我有一个新的黑色三星手机。3\. 询问妈妈之后 然而, 真实的输出顺序是这样的: 1231\. 询问妈妈之前2\. 询问妈妈之后3\. Hey 朋友, 我有一个新的黑色三星手机。 为什么? 因为生命 (或者 JavaScript) 不等人。宝宝在玩的时候等待着妈妈的承诺（promise） (新手机).不是吗? 这个我们称之为 异步（asynchronous）,代码不会因为阻塞或等待结果而不运行. 任何想等待 Promise 之后再运行的, 你需要把他们放入 .then. ES5, ES6/2015, ES7/Next 中的 promiseES5 - 大多数浏览器demo代码在 ES5 的环境（所有主流浏览器+NodeJs）中是可以运行，如果你包含了Bluebird Promise 库。这是因为 ES5 不支持直接调用 Promise 。另一个有名的 Promise 库是 Kris Kowal 的Q。 ES6 / ES2015 - 现代浏览器, NodeJs v6demo代码可以直接调用，因为ES6支持本地 Promise。外加，和 ES6 函数 fat arrow =&gt;，以及 const 和 let 搭配使用，我们可以进一步简化代码`。 这里是 ES6 代码的例子 1234567891011121314151617181920212223242526272829303132333435/* ES6 */const isMomHappy = true;// Promiseconst willIGetNewPhone = new Promise( (resolve, reject) =&gt; &#123; // fat arrow if (isMomHappy) &#123; const phone = &#123; brand: &apos;Samsung&apos;, color: &apos;black&apos; &#125;; resolve(phone); &#125; else &#123; const reason = new Error(&apos;mom is not happy&apos;); reject(reason); &#125; &#125;);const showOff = function (phone) &#123; const message = &apos;Hey 伙计, 我有个一个新&apos; + phone.color + &apos; &apos; + phone.brand + &apos;手机&apos;; return Promise.resolve(message);&#125;;// 调用我们的promiseconst askMom = function () &#123; willIGetNewPhone .then(showOff) .then(fulfilled =&gt; console.log(fulfilled)) // fat arrow .catch(error =&gt; console.log(error.message)); // fat arrow&#125;;askMom(); 注意，所有的var都用 const代替。所有的 function(resolve, reject) 都简化为(resolve, reject) =&gt;。 这些改变有许多好处。阅读更多： JavaScript ES6 的变量声明， let 和 const Javascript ES6 箭头函数介绍 ES7 - 异步等待让语法看上去更整洁ES7 引入 async 和 await 语法。这让异步语法看上去更整洁和易于理解，而不用.then 和 .catch。 用 ES7 的语法重写例子123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/* ES7 */const isMomHappy = true;// Promiseconst willIGetNewPhone = new Promise( (resolve, reject) =&gt; &#123; if (isMomHappy) &#123; const phone = &#123; brand: &apos;Samsung&apos;, color: &apos;black&apos; &#125;; resolve(phone); &#125; else &#123; const reason = new Error(&apos;妈妈不开心&apos;); reject(reason); &#125; &#125;);// 2nd promiseasync function showOff(phone) &#123; return new Promise( (resolve, reject) =&gt; &#123; var message = &apos;Hey 伙计, 我有一个新&apos; + phone.color + &apos; &apos; + phone.brand + &apos;手机&apos;; resolve(message); &#125; );&#125;;// 调用 Promiseasync function askMom() &#123; try &#123; console.log(&apos;before asking Mom&apos;); let phone = await willIGetNewPhone; let message = await showOff(phone); console.log(message); console.log(&apos;after asking mom&apos;); &#125; catch (error) &#123; console.log(error.message); &#125;&#125;(async () =&gt; &#123; await askMom();&#125;)(); 每当你需要在函数中返回一个 Promise 的时候，你要在函数之前添加 async。E.g. async function showOff(phone) 当你需要调用一个 promise，你需要在此之前添加 await。E.g. let phone = await willIGetNewPhone; and let message = await showOff(phone);. 使用 try { ... } catch(error) { ... } 来捕捉 Promise 错误，被拒绝的 promise 为什么用 Promise 以及何时用他们?为什么你需要 promise ？在 promise 之前我们是如何的？在回答这些问题之前，让我们回到基本原理。 普通函数 vs 异步函数让我们看看这两个例子，他们都执行两个数字相加，一个用普通函数相加，一个用远程方法相加。 普通函数相加两个数字1234567// 正常相加数字function add (num1, num2) &#123; return num1 + num2;&#125;const result = add(1, 2); // you get result = 3 immediately 异步函数相加两个数字12345// 远程相加数字// 调用api获得结果const result = getAddResultFromServer(&apos;http://www.example.com?num1=1&amp;num2=2&apos;);// you get result = &quot;undefined&quot; 如果你用普通函数相加两数字，你会马上获得结果。然而如果你发出一个远程调用来获得结果，那么你就需要等待，你不能马上得到结果。 或者这样说，你不知道会不会得到结果，因为服务器可能会性能下降，响应慢等等。你不希望因为等待着结果，让整个进程都被堵住。 调用API，下载文件，读取文件一些平时你会执行的异步操作。 Pomise 出现之前的世界: 回调（Callback）我们一定要用 Prmoise 来做异步回调吗？不是的。优先于 promise ，我们用回调（callback）。回调（callback）仅仅是个你调用的函数，当你获得返回结果的时候。让我们修改之前的例子来获得一个回调。 123456789101112131415// 远程相加两数字// 调用API获得结果function addAsync (num1, num2, callback) &#123; //使用有名的 jQuery getJSON 的回调 API return $.getJSON(&apos;http://www.example.com&apos;, &#123; num1: num1, num2: num2 &#125;, callback);&#125;addAsync(1, 2, success =&gt; &#123; // callback const result = success; // 这里你得到 result = 3&#125;); 这个语法看上去OK，为什么我们之后需要用 Promise ？ 如果你想做一系列的异步操作怎么办？？比如说，不同于一次仅仅相加两个数字，我们希望加3次。用普通的函数，我们这么做： 1234567891011121314// 普通相加两个数字let resultA, resultB, resultC; function add (num1, num2) &#123; return num1 + num2;&#125;resultA = add(1, 2); // 你马上获得 resultA = 3resultB = add(resultA, 3); // 你马上获得 esultB = 6resultC = add(resultB, 4); // 你马上获得 resultC = 10console.log(&apos;total&apos; + resultC);console.log(resultA, resultB, resultC); 用了回调之后，这个看上去是什么样的？ 123456789101112131415161718192021222324252627282930// 远程相加两个数字// 调用API获得结果let resultA, resultB, resultC;function addAsync (num1, num2, callback) &#123; // use the famous jQuery getJSON callback API return $.getJSON(&apos;http://www.example.com&apos;, &#123; num1: num1, num2: num2 &#125;, callback);&#125;addAsync(1, 2, success =&gt; &#123; // callback 1 resultA = success; // you get result = 3 here addAsync(resultA, 3, success =&gt; &#123; // callback 2 resultB = success; // you get result = 6 here addAsync(resultB, 4, success =&gt; &#123; // callback 3 resultC = success; // you get result = 10 here console.log(&apos;total&apos; + resultC); console.log(resultA, resultB, resultC); &#125;); &#125;);&#125;); Demo: https://jsbin.com/barimo/edit?html,js,console 这个语法很不友好。更贴切地说，这个看上去像金字塔，人们经常称呼为 “回调地狱”，因为一个回调嵌在另一个回调之中。想象你有10个回调，你的代码嵌套了10次！ 逃离回调地狱Promise 来拯救你了。让我们看一下相同例子的 Promise 的版本。 1234567891011121314151617181920212223242526272829// 使用observables，远程相加连个数字let resultA, resultB, resultC;function addAsync(num1, num2) &#123; // 使用 ES6 抓取API, 这个返回一个 promise return fetch(`http://www.example.com?num1=$&#123;num1&#125;&amp;num2=$&#123;num2&#125;`) .then(x =&gt; x.json());&#125;addAsync(1, 2) .then(success =&gt; &#123; resultA = success; return resultA; &#125;) .then(success =&gt; addAsync(success, 3)) .then(success =&gt; &#123; resultB = success; return resultB; &#125;) .then(success =&gt; addAsync(success, 4)) .then(success =&gt; &#123; resultC = success; return resultC; &#125;) .then(success =&gt; &#123; console.log(&apos;total: &apos; + success) console.log(resultA, resultB, resultC) &#125;); Demo: https://jsbin.com/qafane/edit?js,console 和 promise 我们用.then让回调在统一层次上。在某种程度上，这个看上去更加干净了，因为没有回调嵌套。当然，用 ES7 async 语法，我们可以加强这个例子，但是我把它留给你。:) 新鲜出炉的属性: 监控属性(observables)在你搞定 Promise 之前，有样叫做Observables的东西出现了，这让你处理异步数据更加简单。 Observables 是懒惰的事件流，这个你可以提交0个或者更多的事件，并且可能不结束。 来源 Promises 和 observables 之间几点关键的差异： Observables 是可以取消的 Observables 是懒惰的 不要怕，让我们看看用 Observables 写相同demo。在这个例子中，我为 Observables 使用 RxJS。 123456789101112131415161718192021let Observable = Rx.Observable;let resultA, resultB, resultC;function addAsync(num1, num2) &#123; // 用 ES6 抓取 API, 返回一个 promise const promise = fetch(`http://www.example.com?num1=$&#123;num1&#125;&amp;num2=$&#123;num2&#125;`) .then(x =&gt; x.json()); return Observable.fromPromise(promise);&#125;addAsync(1,2) .do(x =&gt; resultA = x) .flatMap(x =&gt; addAsync(x, 3)) .do(x =&gt; resultB = x) .flatMap(x =&gt; addAsync(x, 4)) .do(x =&gt; resultC = x) .subscribe(x =&gt; &#123; console.log(&apos;total: &apos; + x) console.log(resultA, resultB, resultC) &#125;); Demo: https://jsbin.com/dosaviwalu/edit?js,console 注意： Observable.fromPromise 将一个 promise 转化为 Observable 流， .do 和 .flatMap 是 observables 提供的操作符中的两个。 流是懒惰的。当我们 .subscribe 它的时候，addAsync 才会运行。 Observables 可以简单地处理恶心的东西。比如，delay 添加 3 seconds 函数，只有一行代码或者充实，因此你可以重试一个调用一定的次数。 123456...addAsync(1,2) .delay(3000) // delay 3 seconds .do(x =&gt; resultA = x) ... 好啦，让我们在未来的文章再讨论 observable 吧！ 总结你有没有熟悉了 callback 和 Promise 呢？ 理解他们使用他们。不要担心 Observable， 也就这样。三个关键因素对你的开发来说，视情况而定。 这里是所有的 妈妈承诺买手机 demo的代码 Demo (ES5): https://jsbin.com/habuwuyeqo/edit?html,js,console Demo (ES6): https://jsbin.com/cezedu/edit?js,console Demo (ES7): https://goo.gl/U3fPmh Github example (ES7): https://github.com/chybie/js-async-await-promise 就这样！希望这篇文章能够铲除你征服 JavaScript Promise 路途上的荆棘、。快乐码农~]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>promise</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React Router 概览]]></title>
    <url>%2F2017%2F04%2F09%2Freact-router-overview%2F</url>
    <content type="text"><![CDATA[React Router的一些概念 React Router为React提供了路由功能的支援。 官方文档。 底层机制 React: state/props -&gt; Components -&gt; UI Router: location -&gt; Router -&gt; UI React Router参数 定义方式,ex: path=&quot;list/:id&quot;. params,ex: ‘this.props.params.id’. React Router教程 在 React 中用 React Router 创建单页应用. React Router.]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>慕课网</tag>
        <tag>React</tag>
        <tag>React Router</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【转】浅析Javascript 中的 this 的七种使用场景]]></title>
    <url>%2F2017%2F04%2F09%2Fjavascript-this%2F</url>
    <content type="text"><![CDATA[原文链接：https://feclub.cn/post/content/this 作者：wqQudian Javascript 中的 this，有时候让人迷惑，所以总结了一下关于this指向的问题。 在函数中 this 到底取何值，是在函数真正被调用执行的时候确定下来的，函数定义的时候确定不了。 因为 this 的取值是函数执行上下文(context)的一部分，每次调用函数，都会产生一个新的执行上下文环境。当代码中使用了 this，这个 this 的值就直接从执行的上下文中获取了，而不会从作用域链中搜寻。 关于 this 的取值，大体上可以分为以下七种情况： 由于严格模式下，禁止this指向全局对象，所以以下示例均运行在非严格模式下 情况一：全局 &amp; 调用普通函数在全局环境中，this 永远指向 window。 1console.log(this === window); //true 普通函数在调用时候(注意不是构造函数，前面不加 new)，其中的 this 也是指向 window。 123456var x = 10;function foo()&#123; console.log(this); //Window console.log(this.x); //10&#125;foo(); 情况二：构造函数所谓的构造函数就是由一个函数 new 出来的对象，一般构造函数的函数名首字母大写，例如像 Object，Function，Array 这些都属于构造函数。 123456function Foo()&#123; this.x = 10; console.log(this); //Foo &#123;x:10&#125;&#125;var foo = new Foo();console.log(foo.x); //10 上述代码，如果函数作为构造函数使用，那么其中的 this 就代表它即将 new 出来的对象。 但是如果直接调用 Foo 函数，而不是 new Foo()，那就变成情况1，这时候 Foo() 就变成普通函数。 12345function Foo()&#123; this.x = 10; console.log(this); //Window&#125;var foo = Foo(); 情况三：对象方法如果函数作为对象的方法时，方法中的 this 指向该对象。 12345678var obj = &#123; x: 10, foo: function () &#123; console.log(this); //Object console.log(this.x); //10 &#125;&#125;;obj.foo(); 注意：若是在对象方法中定义函数，那么情况就不同了。 1234567891011var obj = &#123; x: 10, foo: function () &#123; function f()&#123; console.log(this); //Window console.log(this.x); //undefined &#125; f(); &#125;&#125;obj.foo(); 可以这么理解：函数 f 虽然是在 obj.foo 内部定义的，但它仍然属于一个普通函数，this 仍指向 window。 在这里，如果想要调用上层作用域中的变量 obj.x，可以使用 self 缓存外部 this 变量。 123456789101112var obj = &#123; x: 10, foo: function () &#123; var self = this; function f()&#123; console.log(self); //&#123;x: 10&#125; console.log(self.x); //10 &#125; f(); &#125;&#125;obj.foo(); 如果 foo 函数不作为对象方法被调用： 123456789var obj = &#123; x: 10, foo: function () &#123; console.log(this); //Window console.log(this.x); //undefined &#125;&#125;;var fn = obj.foo;fn(); obj.foo 被赋值给一个全局变量，并没有作为 obj 的一个属性被调用，那么此时 this 的值是 window。 情况四：构造函数 prototype 属性123456789function Foo()&#123; this.x = 10;&#125;Foo.prototype.getX = function () &#123; console.log(this); //Foo &#123;x: 10, getX: function&#125; console.log(this.x); //10&#125;var foo = new Foo();foo.getX(); 在 Foo.prototype.getX 函数中，this 指向的 foo 对象。不仅仅如此，即便是在整个原型链中，this 代表的也是当前对象的值。 情况五：函数用 call、apply或者 bind 调用。12345678910var obj = &#123; x: 10&#125;function foo()&#123; console.log(this); //&#123;x: 10&#125; console.log(this.x); //10&#125;foo.call(obj);foo.apply(obj);foo.bind(obj)(); 当一个函数被 call、apply 或者 bind 调用时，this 的值就取传入的对象的值。 情况六：DOM event this在一个 HTML DOM 事件处理程序里，this 始终指向这个处理程序所绑定的 HTML DOM 节点： 12345678function Listener()&#123; document.getElementById(&apos;foo&apos;).addEventListener(&apos;click&apos;, this.handleClick); //这里的 this 指向 Listener 这个对象。不是强调的是这里的 this&#125;Listener.prototype.handleClick = function (event) &#123; console.log(this); //&lt;div id=&quot;foo&quot;&gt;&lt;/div&gt;&#125;var listener = new Listener();document.getElementById(&apos;foo&apos;).click(); 这个很好理解，就相当于是给函数传参，使 handleClick 运行时上下文改变了，相当于下面这样的代码： 1234567891011var obj = &#123; x: 10, fn: function() &#123; console.log(this); //Window console.log(this.x); //undefined &#125;&#125;;function foo(fn) &#123; fn();&#125;foo(obj.fn); 你也可以用通过 bind 切换上下文: 12345678function Listener()&#123; document.getElementById(&apos;foo&apos;).addEventListener(&apos;click&apos;,this.handleClick.bind(this)); &#125;Listener.prototype.handleClick = function (event) &#123; console.log(this); //Listener &#123;&#125;&#125;var listener = new Listener();document.getElementById(&apos;foo&apos;).click(); 前六种情况其实可以总结为： this 指向调用该方法的对象。 情况七：箭头函数中的 this当使用箭头函数的时候，情况就有所不同了：箭头函数内部的 this 是词法作用域，由上下文确定。 123456789101112131415var obj = &#123; x: 10, foo: function() &#123; var fn = () =&gt; &#123; return () =&gt; &#123; return () =&gt; &#123; console.log(this); //Object &#123;x: 10&#125; console.log(this.x); //10 &#125; &#125; &#125; fn()()(); &#125;&#125;obj.foo(); 现在，箭头函数完全修复了 this 的指向，this 总是指向词法作用域，也就是外层调用者 obj。 如果使用箭头函数，以前的这种 hack 写法： 1var self = this; 就不再需要了。 12345678910111213141516var obj = &#123; x: 10, foo: function() &#123; var fn = () =&gt; &#123; return () =&gt; &#123; return () =&gt; &#123; console.log(this); // Object &#123;x: 10&#125; console.log(this.x); //10 &#125; &#125; &#125; fn.bind(&#123;x: 14&#125;)()()(); fn.call(&#123;x: 14&#125;)()(); &#125;&#125;obj.foo(); 由于 this 在箭头函数中已经按照词法作用域绑定了，所以，用 call()或者 apply()调用箭头函数时，无法对 this 进行绑定，即传入的第一个参数被忽略。]]></content>
      <categories>
        <category>分享</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>this</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React&nbsp;组件构造方法:&nbsp;ES5&nbsp;(createClass)&nbsp;还是&nbsp;ES6&nbsp;(class)？]]></title>
    <url>%2F2017%2F04%2F07%2Freact-es5-or-es6%2F</url>
    <content type="text"><![CDATA[写 React 组件的时候，应该使用 React.createClass 语法还是 ES6 的 class 语法？或两者都不？这篇文章解释了两者之间的一些差异，希望能帮你做决定。 用 ES5 或 ES6 都可以完美地写 React 组件。 使用 JSX 意味着你已经需要一个「构建」步骤，也就是 Babel 将 JSX 转译(transpile)为 React.createElement 调用。很多人充分利用这点， 仅仅向 Babel 的转译列表中添加一项 es2015，就可以自由使用 ES6 的全部特性。 如果你在使用类似 Quik 或React Heatpack 的工具，ES6 就已经为你配置好了。(如果你还没配置过环境可以读一下quick start React(英文)) 比较：createClass vs class下面是同一个组件分别使用 React.createClass 和 ES6 class 的例子： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162var InputControlES5 = React.createClass(&#123; propTypes: &#123; initialValue: React.PropTypes.string &#125;, defaultProps: &#123; initialValue: '' &#125;, // 设置 initial state getInitialState: function() &#123; return &#123; text: this.props.initialValue || 'placeholder' &#125;; &#125;, handleChange: function(event) &#123; this.setState(&#123; text: event.target.value &#125;); &#125;, render: function() &#123; return ( &lt;div&gt; Type something: &lt;input onChange=&#123;this.handleChange&#125; value=&#123;this.state.text&#125; /&gt; &lt;/div&gt; ); &#125;&#125;);class InputControlES6 extends React.Component &#123; constructor(props) &#123; super(props); // 设置 initial state this.state = &#123; text: props.initialValue || 'placeholder' &#125;; // ES6 类中函数必须手动绑定 this.handleChange = this.handleChange.bind(this); &#125; handleChange(event) &#123; this.setState(&#123; text: event.target.value &#125;); &#125; render() &#123; return ( &lt;div&gt; Type something: &lt;input onChange=&#123;this.handleChange&#125; value=&#123;this.state.text&#125; /&gt; &lt;/div&gt; ); &#125;&#125;InputControlES6.propTypes = &#123; initialValue: React.PropTypes.string&#125;;InputControlES6.defaultProps = &#123; initialValue: ''&#125;; 以下是几点关键区别： 函数绑定这可能是最容易犯错的点(tripping point)。 用 createClass 很简单：每一个成员函数都由 React 自动绑定。任何时候需要调用，直接使用 this.whateverFn 即可，函数中的 this 变量在函数调用时会被正确设置。 用 ES6 class 需要当心：函数不是自动绑定的。你必须手动绑定。最好是在构造函数中做这事，就像上面的例子那样。 如果你不想总是手动敲这些函数绑定的代码，可以看看 react-autobind 或 autobing-decorator。 另一个方法是行内绑定，像下面这样： 1234567891011121314151617// 使用 `.bind`:render() &#123; return ( &lt;input onChange=&#123;this.handleChange.bind(this)&#125; value=&#123;this.state.text&#125; /&gt; );&#125;// --- 或 ---// 使用胖箭头函数:render() &#123; return ( &lt;input onChange=&#123;() =&gt; this.handleChange()&#125; value=&#123;this.state.text&#125; /&gt; );&#125; 以上任何一种方法都行的通，但都不如前文的方法有效率。因为每次render 方法被调用的时候（这个调用会相当频繁）就会有一个新的函数被创建。相比于在构造函数中做仅仅一次函数绑定，这个方法会慢一些。 还有一个最终选项是将函数自身替换为胖箭头函数，像这样： 123456789101112131415// 通常的做法// 需要在别处绑定handleChange(event) &#123; this.setState(&#123; text: event.target.value &#125;);&#125;// ES7 做法// 搞定，不需要另外绑定handleChange = (event) =&gt; &#123; this.setState(&#123; text: event.target.value &#125;);&#125; 使用这个方法，你不需要做任何绑定。胖箭头函数的魔法会帮你全部搞定。函数内部的 this 变量会像预期的那样指向组件实例。 唯一的警告是，胖箭头函数是一个「实验性」的特性，也就是说并不在官方的 ES6 标准中。但是它受 Babel 支持，只要启用“stage-0” 预置(preset)即可。如果你喜欢胖箭头语法（读作「令 handleChange 为一个以事件为参数的胖箭头函数），试试看。 构造函数是否调用 super 方法ES6 类构造器需要接受 props 作为参数并调用 super(call)。createClass 并不需要这步，相比之下多了点例行公事(boilerplate)。 class vs createClass这一点显而易见。后者以一个对象为参数调用 React.createClass 方法，前者使用 class 扩展 React.Component 类。 专家提示: 如果你在一个文件中有多个组件，可以直接引入 Component 少打些字：import React, {Component} form &#39;react&#39; Initial State 配置createClass 方法接受一个 getInitialState (译者注：原文误作 initialState）函数作为参数一部分，这个函数会在组件挂载（mount）时被调用一次。 ES6 class 使用构造函数。在调用 super 之后，直接设置 state 即可。 propTypes 和 defaultProps 的位置使用 createClass 的时候，将 propTypes 和 defaultProps 作为你传入的对象的属性。 使用 ES6 class 的时候，这些变成了类本身的属性，所以他们需要在类定义完之后被加到类上。 如果你开启了 ES7 的属性初始化器(property initializer)，可以使用下面的简写法： 12345678910111213class Person extends React.Component &#123; static propTypes = &#123; name: React.PropTypes.string, age: React.PropTypes.string &#125;; static defaultProps = &#123; name: &apos;&apos;, age: -1 &#125;; ...&#125; 忍者第三选项除了 createClass 和 class 外， React 还支持所谓的「无状态(stateless)函数组件」。本质上它就是一个函数，没有 state，并且不能使用任何诸如 componentWillMount 或 shouldComponentUpdate 的生命周期方法。对于接受某些 props 并直接基于这些 props 渲染的简单组件来说，无状态函数组件非常合适。下面是一个例子： 12345function Person(&#123;firstName, lastName&#125;) &#123; return ( &lt;span&gt;&#123;lastName&#125;, &#123;firstName&#125;&lt;/span&gt; );&#125; 这里用到了 ES6 的解构赋值特性来分离传入的 props，也可以写成下面这样： 1234567function Person(props) &#123; var firstName = props.firstName; var lastName = props.lastName; return ( &lt;span&gt;&#123;lastName&#125;, &#123;firstName&#125;&lt;/span&gt; );&#125; 该用哪一个才对？Facebook 已经声明 React.createClass 最终会被 ES6 class 取代，不过他们也说「我们不会废弃 React.createClass，直到我们找到目前 mixin 用例的替代方案，并且在语言中支持类属性初始化器」。 只要有可能，尽量使用无状态函数组件。他们很简单，也会迫使你保持 UI 组件简单。 对于需要 state、生命周期方法、或（通过 refs）访问底层 DOM 节点的复杂组件，使用 class。 不过了解全部三种风格总是有好处的。当你在 StackOverflow 或别的地方查问题的时候，你可能会看到 ES5 和 ES6 两种风格的答案。ES6 风格正在积聚人气，但并不是唯一的风格。 总结可以使用多种方式写 React 组件，我希望这篇概述能帮助你理清这方面的一些困惑。 转自: https://www.w3cplus.com/react/react-es5-createclass-vs-es6-classes.html © w3cplus.com译者：@u9lyfish 原文链接:https://daveceddia.com/react-es5-createclass-vs-es6-classes/作者：@DAVE CEDDIA]]></content>
      <categories>
        <category>分享</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【转】1800X不如7350K？牙膏厂疯狂公关]]></title>
    <url>%2F2017%2F04%2F02%2Fintel-amd%2F</url>
    <content type="text"><![CDATA[前言Intel公关部的实力远在架构部门之上。 损着别人的牙眼，却反对报复，主张宽容的人，万勿和他接近。让他们怨恨去，我也一个都不宽恕。——鲁迅 i3 7350K，目前的最高端处理器，性能远高于6950X、6900K等 本文行文风格为了便于理解，与以往会有所不同(特指措辞。) 新浪钛极客首先是你，新浪网的钛极客。 地址：http://tech.sina.com.cn/roll/2017-03-24/doc-ifycsukm3439190.shtml 防删，使用了web archive，本地还有存档PDF。 https://web.archive.org/web/20170327071918/http://tech.sina.com.cn/roll/2017-03-24/doc-ifycsukm3439190.shtml 搜狐第二个。搜狐网的十八号的老斯基/新潮电子杂志。http://mt.sohu.com/20170323/n484445988.shtml 防删，使用了web archive，本地还有存档PDF。https://web.archive.org/web/20170327072129/http://mt.sohu.com/20170323/n484445988.shtml 中关村下一篇。中关村在线 作者：尹航 责编：李诺，你俩下火狱，钦点了。http://nb.zol.com.cn/632/6327019.html 防删，使用了web archive，本地还有存档PDF。https://web.archive.org/web/20170327072457/http://nb.zol.com.cn/632/6327019.html 还有一篇内容差不多的，居然改成两篇发 http://nb.zol.com.cn/629/6292095.html 更新尹航发的第二篇软文。http://nb.zol.com.cn/632/6321689.html 防删，使用了web archive，本地还有存档PDF。https://web.archive.org/web/20170327072633/http://nb.zol.com.cn/632/6321689.html 电脑爱好者然后是Cfan，亏我小学时候还买过你们杂志，现在变成这个鬼样。http://www.cfan.com.cn/2017/0321/128330.shtml 防删，使用了web archive，本地还有存档PDF。https://web.archive.org/web/20170327072728/http://www.cfan.com.cn/2017/0321/128330.shtml 太平洋还有一篇太平洋大炮洋攻击AM4主板的http://diy.pconline.com.cn/897/8977424_all.html#content_page_2 防删，使用了web archive，本地还有存档PDF。https://web.archive.org/web/20170327072958/http://diy.pconline.com.cn/897/8977424_all.html 啧啧啧，你还有脸来咬人？恶人先告状啊，呵呵 我觉得我都不需要评论了，还是有不少网友能看的明白的，就不知道你自己的脸皮有多厚才敢找上门来。 太平洋太平洋：《4.2GHz的i3意义何在？大众用户用完才知道当中奥妙》http://diy.pconline.com.cn/899/8994865.html 应该是觉得光7350K和Ryzen 7对比太过明显，加了i5 7500和i3 7100这俩鶸 防删，使用了web archive，本地还有存档PDF。https://web.archive.org/web/20170329061104/http://diy.pconline.com.cn/899/8994865.html 外媒数据 那么你们口口声称的解压、视频、图片、娱乐到底对比如何？ 解压首先是解压。 使用7zip 7350K为1800X的34%性能。由于性能差距过大导致表格过长 有人可能会说ComputerBase一个外媒，需要多个来源 那就引用Anandtech的 一样结果，7350K位于倒数第三。 视频编解码然后是视频编解码，使用X265测试 找找7350K在哪。 Anandtech测试的更多，有Handbrake H264/HEVC以及X264 2Pass 毋庸多言。 图像处理图像处理，首先是PS，导入34张RAW 虽然差距不大，但是7350K是不如R7的。 需不需要我去做个坐标轴零点为1:20的柱状图好看得更清楚些？ 以及Pugetsystems专门做的PS多核效率测试 只要多核心能够提升性能， Photoshop就会用到多核心。最多可以达到单线程的6倍以上。 Agisoft Photoscan stage1 AES 附带一个AES测试 游戏应用 1080P下Windows应用及游戏总体分数 近年的单机游戏平均CPU效能，8C/16T的性能发挥比以前好很多 还停留在4核最好的时代？who is more future proof ?不要盲从。 MindBlank的游戏测试顺便附上MindBlank的游戏测试 测试搭配显卡为GTX1070 2200MHz/8900MHz 战地1* GTA5 质量效应 古墓丽影 黑手党3 看门狗2 孤岛危机3 日常办公游戏请购买G4560如果想玩游戏多任务渲染压片直播串流，还想多用个几年不淘汰的，买R7，随便哪个型号都行 如果是CFGO职业选手，对于300+FPS有特殊癖好推荐7700K 本站收集整理，只负责提供打脸资料，打脸工作交给你们。 转载注明出处即可。 想看更多测试成绩建议去看特效药系列：http://www.mykancolle.com/?tag=%E7%89%B9%E6%95%88%E8%8D%AF 原文：我觉得吧你们这些个编辑都该先死个妈http://www.mykancolle.com/?post=1542作者：Marvin 马文]]></content>
      <categories>
        <category>搞机生涯</category>
      </categories>
      <tags>
        <tag>搞机</tag>
        <tag>AMD</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React属性与事件]]></title>
    <url>%2F2017%2F04%2F01%2Freact-prop%2F</url>
    <content type="text"><![CDATA[State 属性 state 对于模块属于 自身 属性 初始化,ex:this.state = {username:&quot;Parry&quot;}; 初始化可以放置在构造函数的constructor里 修改,ex:state: this.setState({username:&quot;IMOOC&quot;}); state 的作用域只属于当前的类，不污染其他模块 Props 属性 Props 对于模块来说属于 外来 属性 传递参数： 模块中接受参数,ex： this.props.username 事件与数据的双向绑定 事件的绑定 注意ES6的语法 可以在构造函数里绑定，ex：this.forceUpdateHandler = this.forceUpdateHandcler.bind(this); 调用时绑定，ex：onlick = {this.changeUserInfo.bind(this,50)} 子页面向父页面传递参数的方法 在子页面中通过调用父页面传递过来的事件props进行组件间的参数传递 onChange与传统onBlur之间的差异 可复用组件 Prop 验证 ex: 1const propTypes=&#123;id:PropTypes.numberr.isRequired,url:PropTypes.string.isRequired,text: PropTypes.string&#125;; 使用方法，ex:BodyIndex.propTypes = {userid:React.PropTypes.number.isRequired}; 默认 Prop 值 ex：const defaultProps = {text: &#39;Hello World&#39;}; 使用方法，ex:BodyIndex.defaultProps = defaultProps; 传递所有参数的快捷方式 ex:&lt;Component{...this.props} more = &quot;values&quot; /&gt; 组件的 Refs 原始获取方法，ex: 12var myDiv = document.getElementById('myDiv');ReactDom.findeDomNode(myDiv).style.color = 'red'; 方法二的获取，ex：this.refs.myInput Refs 是访问到组件内部DOM节点唯一可靠的方法 Refs 会自动销毁对子组件的引用 不要再 render 或 render 之前对 Refs 进行调用 避免滥用 Refs 独立组件间共享 MIxins 不同组件之间共用功能、共享代码 和页面具有类似的生命周期 ES6下的使用需要安装插件 关于 Mixins 的讨论文章]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>慕课网</tag>
        <tag>React</tag>
        <tag>React属性</tag>
        <tag>React事件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React组件基础]]></title>
    <url>%2F2017%2F03%2F30%2Freact-components%2F</url>
    <content type="text"><![CDATA[React 虚拟 DOM 概念 React 组件 组件是 React 的一个主要特性 组件对于模块化开发的重要性 组件的 return 函数里返回的HTML节点必须是一个 可以给外部使用的组件定义, ex： export default class ComponentHeader extends. 入口的定义，ex：ReactDOM.render(,document.getElementById(&#39;example&#39;)); React 多组件的嵌套 组件也可以通过参数的形式传递 项目命名的规范与文件的结构化 JSX 内置表达式 ex: {window.userName == &quot;? &#39;default username&#39;:&#39;userName&#39; + userName&quot;} {/注释/} HTML 转义字符要显示需要进行Unicode转码 转义字符还可以通过 dangerouslySetInnerHTML ,缺点是容易受到 xss 攻击。 生命周期 流程图]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>慕课网</tag>
        <tag>React</tag>
        <tag>React组件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FCC高级算法题]]></title>
    <url>%2F2017%2F03%2F29%2Ffcc-senior%2F</url>
    <content type="text"><![CDATA[Validate US Telephone Numbers如果传入字符串是一个有效的美国电话号码，则返回 true. 用户可以在表单中填入一个任意有效美国电话号码. 下面是一些有效号码的例子(还有下面测试时用到的一些变体写法):555-555-5555(555)555-5555(555) 555-5555555 555 555555555555551 555 555 5555在本节中你会看见如 800-692-7753 or 8oo-six427676;laskdjf这样的字符串. 你的任务就是验证前面给出的字符串是否是有效的美国电话号码. 区号是必须有的. 如果字符串中给出了国家代码, 你必须验证其是 1. 如果号码有效就返回 true ; 否则返回 false. 12345function telephoneCheck(str) &#123; var reg=/^1? ?(\d&#123;3&#125;|\(\d&#123;3&#125;\))[ -]?\d&#123;3&#125;[ -]?\d&#123;4&#125;$/; var res=reg.test(str); return res;&#125; Symmetric Difference创建一个函数，接受两个或多个数组，返回所给数组的 对等差分(symmetric difference) (△ or ⊕)数组. 给出两个集合 (如集合 A = {1, 2, 3} 和集合 B = {2, 3, 4}), 而数学术语 “对等差分” 的集合就是指由所有只在两个集合其中之一的元素组成的集合(A △ B = C = {1, 4}). 对于传入的额外集合 (如 D = {2, 3}), 你应该安装前面原则求前两个集合的结果与新集合的对等差分集合 (C △ D = {1, 4} △ {2, 3} = {1, 2, 3, 4}). 1234567891011121314151617181920212223242526272829function sym(args) &#123; var newArgs = Array.prototype.slice.call(arguments);//转化数组 function diff(arr1,arr2)&#123; //闭包函数 arr1 = Array.from(new Set(arr1)); arr2 = Array.from(new Set(arr2));//对参数进行去重 var counter = arr2.length; for(i = 0;i&lt;arr1.length;i++)&#123; counter --; arr2 = arr2.filter(function(val)&#123; return val !== arr1[i]; &#125;);//遍历arr2，并返回arr2不与arr1重复的元素 if(counter&lt;arr2.length)&#123; arr2.push(arr1[i]);//将arr1中不与arr2重复的元素添加进arr2中 counter = arr2.length; &#125;else&#123; continue; &#125; &#125; return arr2; &#125; for(x = 0;x&lt;newArgs.length-1;x++)&#123; newArgs[x+1] = diff(newArgs[x],newArgs[x+1]);//对newArgs数组进行遍历 &#125; return newArgs[newArgs.length-1];&#125;sym([1, 1, 2, 5], [2, 2, 3, 5], [3, 4, 5, 5]); Exact Change设计一个收银程序 checkCashRegister() ，其把购买价格(price)作为第一个参数 , 付款金额 (cash)作为第二个参数, 和收银机中零钱 (cid) 作为第三个参数. cid 是一个二维数组，存着当前可用的找零. 当收银机中的钱不够找零时返回字符串 “Insufficient Funds”. 如果正好则返回字符串 “Closed”. 否则, 返回应找回的零钱列表,且由大到小存在二维数组中. 本题代码来自fcc的wiki 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354var denom = [ &#123; name: 'ONE HUNDRED', val: 100.00&#125;, &#123; name: 'TWENTY', val: 20.00&#125;, &#123; name: 'TEN', val: 10.00&#125;, &#123; name: 'FIVE', val: 5.00&#125;, &#123; name: 'ONE', val: 1.00&#125;, &#123; name: 'QUARTER', val: 0.25&#125;, &#123; name: 'DIME', val: 0.10&#125;, &#123; name: 'NICKEL', val: 0.05&#125;, &#123; name: 'PENNY', val: 0.01&#125;];function checkCashRegister(price, cash, cid) &#123; var change = cash - price;// 遍历cid数组获得一个带有目前零钱总数和各零钱数额的register对象 var register = cid.reduce(function(acc, curr) &#123; acc.total += curr[1]; acc[curr[0]] = curr[1]; return acc; &#125;, &#123;total: 0&#125;);//零钱正好找完 if (register.total === change) &#123; return 'Closed'; &#125;// 零钱不够了 if (register.total &lt; change) &#123; return 'Insufficient Funds'; &#125;// 遍历denom数组 var change_arr = denom.reduce(function(acc, curr) &#123; var value = 0; // while该面值零钱仍有余额 // 面值应当小于或等于找零 while (register[curr.name] &gt; 0 &amp;&amp; change &gt;= curr.val) &#123; change -= curr.val; register[curr.name] -= curr.val; value += curr.val;// 消除浮点数误差 change = Math.round(change * 100) / 100; &#125; if (value &gt; 0) &#123; acc.push([ curr.name, value ]); &#125; return acc; &#125;, []); // Initial value of empty array for reduce// change_arr数组若没有元素或者无法找尽零钱，返回零钱不够了 if (change_arr.length &lt; 1 || change &gt; 0) &#123; return "Insufficient Funds"; &#125;// Here is your change, ma'am. return change_arr;&#125;// test herecheckCashRegister(19.50, 20.00, [["PENNY", 1.01], ["NICKEL", 2.05], ["DIME", 3.10], ["QUARTER", 4.25], ["ONE", 90.00], ["FIVE", 55.00], ["TEN", 20.00], ["TWENTY", 60.00], ["ONE HUNDRED", 100.00]]); Inventory Update依照一个存着新进货物的二维数组，更新存着现有库存(在 arr1 中)的二维数组. 如果货物已存在则更新数量 . 如果没有对应货物则把其加入到数组中，更新最新的数量. 返回当前的库存数组，且按货物名称的字母顺序排列. 12345678910111213141516171819202122function updateInventory(arr1, arr2) &#123; arr1.forEach(function(v,ind,a)&#123; for(i=0;i&lt;arr2.length;i++)&#123; if(arr2[i][1] == v[1])&#123; v[0] +=arr2[i][0]; &#125; &#125; &#125;); for(i=0;i&lt;arr1.length;i++)&#123; arr2 = arr2.filter(function(val)&#123; return val[1] !== arr1[i][1]; &#125;); &#125; var newArr = arr1.concat(arr2); newArr.sort(function(a,b)&#123; return a[1].charCodeAt(0)-b[1].charCodeAt(0); &#125;); return newArr;&#125;// Example inventory listsupdateInventory([[21, "Bowling Ball"], [2, "Dirty Sock"], [1, "Hair Pin"], [5, "Microphone"]], [[2, "Hair Pin"], [3, "Half-Eaten Apple"], [67, "Bowling Ball"], [7, "Toothpaste"]]); No repeats please把一个字符串中的字符重新排列生成新的字符串，返回新生成的字符串里没有连续重复字符的字符串个数.连续重复只以单个字符为准 例如, aab 应该返回 2 因为它总共有6中排列 (aab, aab, aba, aba, baa, baa), 但是只有两个 (aba and aba)没有连续重复的字符 (在本例中是 a). 123456789101112131415161718192021222324function permAlone(str) &#123; var reg = /(.)\1+/g;//正则 var newArr = str.split(''); var r = []; var num = str.length; (function f(t,a,n)&#123; if(n===0)&#123; return r.push(t); &#125; for(var i=0;i&lt;a.length;i++)&#123; f(t.concat(a[i]),a.slice(0,i).concat(a.slice(i+1)),n-1); &#125; &#125;)([],newArr,num);//对数组进行全排列 var res = r.map(function(val)&#123; return val.join(''); &#125;); res = res.filter(function(val)&#123; return !val.match(reg); &#125;);//匹配正则 return res.length;&#125;permAlone('aab'); Friendly Date Ranges让日期区间更友好！ 把常见的日期格式如：YYYY-MM-DD 转换成一种更易读的格式。 易读格式应该是用月份名称代替月份数字，用序数词代替数字来表示天 (1st 代替 1). 记住不要显示那些可以被推测出来的信息: 如果一个日期区间里结束日期与开始日期相差小于一年，则结束日期就不用写年份了。月份开始和结束日期如果在同一个月，则结束日期月份就不用写了。 另外, 如果开始日期年份是当前年份，且结束日期与开始日期小于一年，则开始日期的年份也不用写。 例如: makeFriendlyDates([“2016-07-01”, “2016-07-04”]) 应该返回 [“July 1st”,”4th”] makeFriendlyDates([“2016-07-01”, “2018-07-04”]) 应该返回 [“July 1st, 2016”, “July 4th, 2018”]. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273function makeFriendlyDates(arr) &#123; var Month = ["", "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December" ],//月份转换数组 result = []; function test(dateStr) &#123; dateStr = parseInt(dateStr,10); switch (dateStr) &#123; case 1: dateStr += 'st'; break; case 2: dateStr += 'nd'; break; case 3: dateStr += 'rd'; break; default: dateStr += 'th'; break; &#125; return dateStr;&#125;//日期转换 var date1 = test(arr[0].substr(-2)), date2 = test(arr[1].substr(-2)), arr1 = arr[0].split('-'), arr2 = arr[1].split('-'), year = arr2[0]-arr1[0], month = arr2[1]-arr1[1], date = arr2[2]-arr1[2], month1 = arr[0].substr(5,2), month2 = arr[1].substr(5,2), year1 = arr[0].substr(0,4), year2 = arr[1].substr(0,4); switch(year)&#123; case 0: if(month ==11 &amp;&amp; date == 30)&#123; //同年01-01和12-31 result.push(Month[parseInt(month1,10)]+' '+date1+', '+year1,Month[parseInt(month2,10)]+' '+date2+', '+year2); &#125;else if(month === 0)&#123; if (date !== 0)&#123; //同年同月不同日 result.push(Month[parseInt(month1,10)]+' '+date1,date2); &#125;else&#123; //同年同月同日 result.push(Month[parseInt(month1,10)]+' '+date1+', '+year1); &#125; &#125;else&#123; //同年不同月 result.push(Month[parseInt(month1,10)]+' '+date1+', '+year1,Month[parseInt(month2,10)]+' '+date2); &#125; break; case 1: if((month === 0 &amp;&amp; date == -1)||month &gt;0)&#123; //差一年整 result.push(Month[parseInt(month1,10)]+' '+date1+', '+year1,Month[parseInt(month2,10)]+' '+date2); &#125;else if(month === 0 &amp;&amp; date &gt; -1)&#123; //差一年同月，大于一年 result.push(Month[parseInt(month1,10)]+' '+date1+', '+year1,Month[parseInt(month2,10)]+' '+date2+', '+year2); &#125;else&#123; //差一年，大于一年 result.push(Month[parseInt(month1,10)]+' '+date1,Month[parseInt(month2,10)]+' '+date2); &#125; break; default: result.push(Month[parseInt(month1,10)]+' '+date1+', '+year1,Month[parseInt(month2,10)]+' '+date2+', '+year2);&#125; return result;&#125;makeFriendlyDates(["2018-01-01", "2018-12-31"]); Make a Person用下面给定的方法构造一个对象. 方法有 getFirstName(), getLastName(), getFullName(), setFirstName(first), setLastName(last), and setFullName(firstAndLast). 所有有参数的方法只接受一个字符串参数. 所有的方法只与实体对象交互. 思路比较混乱，首先为了避免后面的代码影响到前面获取名字(get****Name)这几行代码，在更改时尽量将改变的数据存储到函数作用域内声明的变量中。123456789101112131415161718192021222324252627var Person = function(firstAndLast) &#123; var fullName = firstAndLast.split(' '),firstName = fullName[0],lastName = fullName[1]; this.getFirstName = function()&#123; return firstName; &#125;; this.getLastName = function()&#123; return lastName; &#125;; this.getFullName = function()&#123; return firstName+' '+lastName; &#125;; this.setFirstName = function(first)&#123; firstName = first; &#125;; this.setLastName = function(last)&#123; lastName = last; &#125;; this.setFullName = function(firstAndLast)&#123; firstName = firstAndLast.split(' ')[0]; lastName = firstAndLast.split(' ')[1]; &#125;;&#125;;var bob = new Person('Bob Ross');bob.getFullName(); Map the Debris返回一个数组，其内容是把原数组中对应元素的平均海拔转换成其对应的轨道周期. 原数组中会包含格式化的对象内容，像这样 {name: ‘name’, avgAlt: avgAlt}. 至于轨道周期怎么求，戳这里 on wikipedia (不想看英文的话可以自行搜索以轨道高度计算轨道周期的公式). 求得的值应该是一个与其最接近的整数，轨道是以地球为基准的. 地球半径是 6367.4447 kilometers, 地球的GM值是 398600.4418, 圆周率为Math.PI 123456789101112function orbitalPeriod(arr) &#123; var GM = 398600.4418; var earthRadius = 6367.4447, altitude = []; for(var i=0;i&lt;arr.length;i++)&#123; arr[i].orbitalPeriod = Math.round(2*Math.PI*Math.sqrt(Math.pow((earthRadius+arr[i].avgAlt),3)/GM)); delete arr[i].avgAlt; &#125; return arr;&#125;orbitalPeriod([&#123;name : "sputnik", avgAlt : 35873.5553&#125;]); Pairwise（找到你的另一半）都说优秀的程序员擅长面向对象编程，但却经常找不到另一半，这是为什么呢？因为你总是把自己局限成为一个程序员，没有打开自己的思维。 这是一个社群的时代啊，在这里你应该找到与你有相同价值观但又互补的另一半。 譬如：你编程能力强，估值11分，如果以20分为最佳情侣来计算，你应该找一个设计能力强，估值为9分的女生。 那么当你遇到一个设计能力为9分的女生，千万别犹豫，大胆去表白。千万别以为后面的瓜比前面的甜哦。 举个例子：有一个能力数组[7,9,11,13,15]，按照最佳组合值为20来计算，只有7+13和9+11两种组合。而7在数组的索引为0，13在数组的索引为3，9在数组的索引为1，11在数组的索引为2。 所以我们说函数：pairwise([7,9,11,13,15],20) 的返回值应该是0+3+1+2的和，即6。 1234567891011121314function pairwise(arr, arg) &#123; var a = arr.reduce(function(acc,curr,ind,array)&#123; for(var i=ind+1;i&lt;array.length;i++)&#123; if(array[ind] + array[i] == arg)&#123; array[ind] = array[i] = NaN; return acc+i+ind; &#125; &#125; return acc; &#125;,0); return a;&#125;pairwise([1, 3, 2, 4], 4);]]></content>
      <categories>
        <category>习题集</category>
      </categories>
      <tags>
        <tag>算法习题</tag>
        <tag>reecodecamp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FCC中级算法题]]></title>
    <url>%2F2017%2F03%2F29%2Ffcc-mid%2F</url>
    <content type="text"><![CDATA[Pig Latin 儿童黑话需求：把指定的字符串翻译成 pig latin。Pig Latin 把一个英文单词的第一个辅音或辅音丛（consonant cluster）移到词尾，然后加上后缀 “ay”。如果单词以元音开始，你只需要在词尾添加 “way” 就可以了。见过网上其他人的方法，都是先确定单词内是否具有元音字母，之后还需要你确定是否构成单词。此处，为了简化代码，不做单词的验证，同时，第一次测试将实验直接验证首字母为元音是否可行。12345678910111213141516171819202122232425function translate(str) &#123; var p=/[^aeiou]/; var index=0; //计算出第一个元音字母在字符串中的位置 for(var i=0; i&lt;str.length; i++)&#123; if(p.test(str.charAt(i)))&#123; continue; &#125; index = i; break; &#125; //元音字母为首字母时，给字符串加way后缀 if(index===0)&#123; str+='way'; &#125; //将辅音丛加至结尾,并加上'ay'后缀 else&#123; var arr=str.split(''); var del=arr.splice(0,index); arr=arr.concat(del); str=arr.join('') + 'ay'; &#125; return str;&#125;translate("glove") ; DNA Pairing DNA配对DNA 链缺少配对的碱基。依据每一个碱基，为其找到配对的碱基，然后将结果作为第二个数组返回。Base pairs（碱基对） 是一对 AT 和 CG，为给定的字母匹配缺失的碱基。在每一个数组中将给定的字母作为第一个碱基返回。例如，对于输入的 GCG，相应地返回 [[“G”, “C”], [“C”,”G”],[“G”, “C”]]字母和与之配对的字母在一个数组内，然后所有数组再被组织起来封装进一个数组。1234567891011121314151617function pair(str) &#123; var newArr = str.split(''); for(i=0;i&lt;newArr.length;i++)&#123; switch (newArr[i])&#123; case "G":newArr[i] = newArr[i]+"C";break; case "C":newArr[i] = newArr[i]+"G";break; case "A":newArr[i] = newArr[i]+"T";break; case "T":newArr[i] = newArr[i]+"A";break; &#125; newArr[i] = newArr[i].split(''); &#125; return newArr;&#125;pair("GCG"); Missing letter 消失的字母从传递进来的字母序列中找到缺失的字母并返回它。如果所有字母都在序列中，返回 undefined。 123456789101112131415function fearNotLetter(str) &#123; for(i=0;i&lt;str.length;i++)&#123; var a = str.charCodeAt(i)-str.charCodeAt(i-1); if( a !== 1)&#123; for(j=0;j&lt;a-1;j++)&#123; return String.fromCharCode(str.charCodeAt(i)-1); &#125; &#125; &#125;&#125;fearNotLetter("bcd"); Boo whotype of 12345function boo(bool) &#123; return (typeof bool=='boolean');&#125;boo([1, 2, 3]); Sorted Union写一个 function，传入两个或两个以上的数组，返回一个以给定的原始数组排序的不包含重复值的新数组。换句话说，所有数组中的所有值都应该以原始顺序被包含在内，但是在最终的数组中不包含重复值。非重复的数字应该以它们原始的顺序排序，但最终的数组不应该以数字顺序排序。 本题的思路在于，传入的实参数量是不一定的，因此，不能直接对几个形参使用array.concat();，使用arguments();来获取实参数值。然后进行去重。 12345678910function unite(arr1, arr2, arr3) &#123; var newArr1 = Array.prototype.slice.call(arguments); newArr1 = newArr1.reduce(function(a,b)&#123; return a.concat(b); &#125;); var newArr2 = Array.from(new Set(newArr1)); return newArr2;&#125;unite([1, 3, 2], [5, 2, 1, 4], [2, 1]); Convert HTML Entities将字符串中的字符 &amp;、&lt;、&gt;、” （双引号）, 以及 ‘ （单引号）转换为它们对应的 HTML 实体。 这里需要使用到str.match(),该函数可以返回匹配到的字符 关于正则中的几个修饰符 i：不分大小写 g:匹配所有（否则仅仅匹配一个） m:多行匹配，搭配^和$ 123456789101112131415161718192021function convert(str) &#123; var p = /[&amp;&lt;&gt;"']/g; var HtmlEntities = &#123; '&amp;':'&amp;amp;', '&lt;':'&amp;lt;', '&gt;':'&amp;gt;', "'":"&amp;apos;", '"':'&amp;quot;' &#125;; var arr = str.match(p); if(!arr)&#123; return str; &#125;else&#123; for(i=0;i&lt;arr.length;i++)&#123; str = str.replace(arr[i],HtmlEntities[arr[i]]); &#125; &#125; return str;&#125;convert("Dolce &amp; Gabbana"); Spinal Tap Case将字符串转换为 spinal case。Spinal case 是 all-lowercase-words-joined-by-dashes 这种形式的，也就是以连字符连接所有小写单词。123456789101112131415161718192021222324252627282930313233343536function spinalCase(str) &#123; var newStr = ''; if(str.match(/ /))&#123; for(i=0;i&lt;str.length;i++)&#123; str = str.replace(' ','-'); &#125; return str.toLowerCase();//首先判断，当单词之间有空格时，可直接替换 &#125;else&#123; newStr = str.replace(/[^a-zA-Z]/g,""); var p = /[A-Z]/g; var arr = newStr.match(p); var newArr = newStr.split(''); for(i=0;i&lt;arr.length;i++)&#123; newArr.splice(newStr.indexOf(arr[i]),0,'-');//在每个大写字母前添加"-" newStr = newArr.join('');//由于添加完后的数组已经发生变化，索引和原始字符串不再一致，需要重新定义字符串 /*var a = newStr.indexOf(arr[i]); var b= newStr.indexOf(arr[i+1]); newArr[i] = newStr.slice(a,b);*/ &#125; if(/[a-zA-z]/.test(newArr[0]))&#123; newStr = newArr.join('').toLowerCase(); &#125;else&#123; newArr.shift(); newStr = newArr.join('').toLowerCase(); &#125; // 如果首字母也为大写，那么需要进行判断来删除首字母前面添加的'-' return newStr; &#125;&#125;spinalCase("The_Andy_Griffith_Show"); Sum All Odd Fibonacci Numbers给一个正整数num，返回小于或等于num的斐波纳契奇数之和。斐波纳契数列中的前几个数字是 1、1、2、3、5 和 8，随后的每一个数字都是前两个数字之和。例如，sumFibs(4)应该返回 5，因为斐波纳契数列中所有小于4的奇数是 1、1、3。 提示：此题不能用递归来实现斐波纳契数列。因为当num较大时，内存会溢出，推荐用数组来实现。12345678910111213141516171819var sumFibs = function() &#123; var cache = [1,1]; return function(num)&#123; if(num&gt;=cache.length)&#123; for(var i= cache.length;i&lt;num;i++)&#123; cache[i] = cache[ i-2 ] + cache [i - 1]; &#125; &#125; var arr = cache.filter(function(ele)&#123; return ele%2 !== 0&amp;&amp;ele &lt;= num; &#125;); return arr.reduce(function(a,b)&#123; return a+b; &#125;); &#125;;&#125;();sumFibs(4); Sum All Primes求小于等于给定数值的质数之和。 只有 1 和它本身两个约数的数叫质数。例如，2 是质数，因为它只能被 1 和 2 整除。1 不是质数，因为它只能被自身整除。 给定的数不一定是质数。 首先需要了解求质数的算法，比较受推荐有两种。 首先尝试2，然后尝试只要尝试小于√x 的质数（因数的成对出现）； 筛法。首先，2是公认最小的质数，所以，先把所有2的倍数去掉；然后剩下的那些大于2的数里面，最小的是3，所以3也是质数；然后把所有3的倍数都去掉，剩下的那些大于3的数里面，最小的是5，所以5也是质数…… 刚开始的思路是，创建一个0-n的数组，对数组的value进行筛选,但是这样性能很差，数组内每个数字占内存较大，想到创建一个n的数组，获取索引值并判断，将布尔值存入数组索引位置，最后在获得索引值index，相加即可。 12345678910111213141516171819202122232425function sumPrimes(num) &#123; var newArr = Array(num+1).fill(true); newArr[0] = newArr[1] = false; for(i=2;i&lt;= Math.sqrt(num);i++)&#123; if(newArr[i])&#123; for(j=i;j*i&lt;= num;j++)&#123; newArr[j*i] = false; &#125; &#125; &#125; var resArr = []; for(x =0;x&lt; newArr.length;x++)&#123; resArr.push(newArr.indexOf(true,x)); &#125; resArr = Array.from(new Set(resArr)).filter(function(val)&#123; return val&gt;0; &#125;); return resArr.reduce(function(a,b)&#123; return a + b; &#125;);&#125;sumPrimes(10); Smallest Common Multiple最小公倍数 在此之前要了解欧拉算法求最大公约数。简单的说，求两个数的最大公约数，用大数对小数求模，如果能被整除，则小数是这两个数的最大公约数。如果不能整除，就用小数对余数再次求模，循环此过程直到返回能除尽的那个除数。就是最大公约数。比如20和15，用20除以15余数为5，然后用15除以余数5，能够整除，所以返回出来的除数5为这两个数的最大公约数。 有了最大公约数，就可以求最小公倍数。最小公倍数的求法是：彼此之间的乘积除以最大公约数。 因为是求几个连续自然数之间的公倍数，所以，求出前两个最小公倍数之后，用这个最小公倍数和下一个值比较。然后就得出了新的最小公倍数。主要用的是递归的思想。 12345678910111213141516171819202122function smallestCommons(arr) &#123; var resArr = []; arr = arr.sort(function(pre,next)&#123; return next-pre; &#125;); var max = function(m,n)&#123; if(m%n === 0)&#123; return n; &#125;else&#123; return max(n,m%n); &#125; &#125;; var num = arr[1]; for(var i = arr[1]+1;i&lt;=arr[0];i++)&#123; num *=i/max(num,i); &#125; return num;&#125;smallestCommons([1,13]); Finders Keepers12345678910111213141516function find(arr, func) &#123; var num = 0; for(i=0;i&lt;arr.length;i++)&#123; if(func(arr[i]))&#123; num = arr[i]; break; &#125; &#125; if (num === 0)&#123; return undefined; &#125; return num;&#125;find([1, 3, 5, 8, 9, 10], function(num)&#123; return num % 2 === 0; &#125;); Drop it让我们来丢弃数组(arr)的元素，从左边开始，直到回调函数return true就停止。 第二个参数，func，是一个函数。用来测试数组的第一个元素，如果返回fasle，就从数组中抛出该元素(注意：此时数组已被改变)，继续测试数组的第一个元素，如果返回fasle，继续抛出，直到返回true。 最后返回数组的剩余部分，如果没有剩余，就返回一个空数组。 我的思路是先先通过filter遍历后获得同伙函数的值，将遍历后数组的第一个元素与传入的arr数组进行indexOf索引匹配，然后用silce()分割即可，这里要注意，如果遍历后所得数组为空，需要做判断。 123456789101112131415function drop(arr, func) &#123; var newArr = arguments[0];// Drop them elements. newArr = newArr.filter(function(val)&#123; return func(val); &#125;); if(newArr.length!== 0)&#123; arr = arr.slice(arr.indexOf(newArr[0])); &#125; else&#123; arr = []; &#125; return arr;&#125;drop([1, 2, 3, 4], function(n) &#123;return n &gt; 5;&#125;); Steamroller对嵌套的数组进行扁平化处理。你必须考虑到不同层级的嵌套。如果只在外面声明一个全局的新数组，那么无法得出新数组，而在函数内声明，则需要使用闭包。 12345678910111213141516function steamroller(arr) &#123; var result = []; function steam(ifarr)&#123; if(Array.isArray(ifarr))&#123; return ifarr.forEach(function(val)&#123; return steam(val); &#125;); &#125;else&#123; result.push(ifarr); &#125; &#125; steam(arr); return result;&#125;steamroller([1, [2], [3, [[4]]]]); Binary Agents传入二进制字符串，翻译成英语句子并返回。 二进制字符串是以空格分隔的。parseInt转换进制，map遍历数组 123456789function binaryAgent(str) &#123; var newArr = str.split(' '); newArr = newArr.map(function(val)&#123; return String.fromCharCode(parseInt(val,2)); &#125;); return newArr.join('');&#125;binaryAgent("01000001 01110010 01100101 01101110 00100111 01110100 00100000 01100010 01101111 01101110 01100110 01101001 01110010 01100101 01110011 00100000 01100110 01110101 01101110 00100001 00111111"); Everything Be True完善编辑器中的every函数，如果集合(collection)中的所有对象都存在对应的属性(pre)，并且属性(pre)对应的值为真。函数返回ture。反之，返回false。 123456789101112function every(collection, pre) &#123; var counter = 0;// Create a counter to check how many are true. for(var i in collection)&#123; // Check for each object if(collection[i].hasOwnProperty(pre) &amp;&amp; Boolean(collection[i][pre]))&#123; counter++; &#125; // If it is has property and value is truthy &#125; return counter == collection.length;&#125;// Outside the loop, check to see if we got true for all of them and return true or falseevery([&#123;"user": "Tinky-Winky", "sex": "male"&#125;, &#123;"user": "Dipsy", "sex": "male"&#125;, &#123;"user": "Laa-Laa", "sex": "female"&#125;, &#123;"user": "Po", "sex": "female"&#125;], "sex"); Arguments Optional创建一个计算两个参数之和的 function。如果只有一个参数，则返回一个 function，该 function 请求一个参数然后返回求和的结果。 例如，add(2, 3) 应该返回 5，而 add(2) 应该返回一个 function。 调用这个有一个参数的返回的 function，返回求和的结果： var sumTwoAnd = add(2); sumTwoAnd(3) 返回 5。 如果两个参数都不是有效的数字，则返回 undefined。 12345678910111213141516171819function add() &#123; if(typeof arguments[0] !== 'number' || (arguments.length&gt;1 &amp;&amp; typeof arguments[1] !== 'number'))&#123; return undefined; &#125; if(arguments.length!=2)&#123; var newArg = arguments[0]; return function(num)&#123; if(typeof num !== 'number')&#123; return undefined; &#125;else&#123; return newArg + num; &#125; &#125;; &#125;else&#123; return arguments[0]+arguments[1]; &#125;&#125;]]></content>
      <categories>
        <category>习题集</category>
      </categories>
      <tags>
        <tag>算法习题</tag>
        <tag>reecodecamp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML中的增强型表单标签]]></title>
    <url>%2F2017%2F03%2F27%2Fh5-newTitle-01%2F</url>
    <content type="text"><![CDATA[一、增型表单标签HTML5中，新标准把文本框提示信息、表单校验、日期选择控件、颜色选择控件、范围控件、进度条、标签跨表单等功能直接加入新的表单标签中。 但在众多现代浏览器中，最新版本的Opera浏览器对新型表单的支持才最为完美。 1. Number类型input标签1&lt;input type="number" name="demoNumber" min="1" max="100" step="1"/&gt; name: 标识表单提交时的key值 min: 标识当前输入框输入的最小值 max: 标识当前输入框输入的最大值 step: 标识点击增大/减小的时候，增加/减小的步长 2. Email类型input标签1&lt;input type="email" name="email" placeholder="请输入注册邮箱"/&gt; 当表单在提交前，此文本框会自动校验是否符合邮箱的正则表达式。 3. URL类型的input标签1&lt;input type="url" placeholder="请输入网址" name="url"/&gt; 4. Tel类型的input标签1&lt;input type="tel" placeholder="输入电话" name="phone"/&gt; 5. range类型的input标签1&lt;input type="range" min="0" max="50" step="5" name="rangedemo" value="0"/&gt; 此类型标签的加入，输入范围内的数据变得非常简单容易，而且非常标准，用户输入可感知体验非常好。另外此标签可以跟表单新增加的output标签一块使用，达到一个联动的效果。1234&lt;form oninput="output.value=parseInt(range.value)"/&gt; &lt;input type="range" min="0" max="100" step="5" name="range" value="0"/&gt; &lt;output name="output"&gt;0&lt;output/&gt;&lt;/form&gt; 6. 新的日期、时间、月份、星期input标签Web项目开发，一定会遇到相关的js日期控件，在HTML5中新加入的表单属性将会使Web开发变得更加简洁。1&lt;input type="date" name="datedemo"/&gt; 相关的日期属性还包括：month、time、week、datetime-local、datetime 7. 颜色选择input标签1&lt;input type=&quot;color&quot; name=&quot;colordemo&quot;/&gt; 8. input标签自动完成功能有的项目会要求实现自动完成或者输入提示功能，在HTML5的支持下将变得简单。 123456&lt;input type="text" autocomplete="on" name="demoAutoComplete" list="autoNames" /&gt;&lt;datalist id="autoNames"&gt; &lt;option value="实验楼" &gt;&lt;/option&gt; &lt;option value="HTML5" &gt;&lt;/option&gt; &lt;option value="input标签" &gt;&lt;/option&gt;&lt;/datalist&gt; 二、HTML5表单新属性1. input表单新增加的特有属性autofocus 属性，demo:1&lt;input type="text" autofocus="autofocus"/&gt; 此属性可以设置当前页面中input标签加载完毕后获得焦点。 max、min、step：这些上面介绍过，都是跟数字相关。 placeholder：提示信息属性。 multiple：用于文件上传控件，设置此属性后，允许多个文件。 校验属性：设置了required属性后预示着当前文本框在提交前必须有数据输入，而这一切都是由浏览器自动完成。还添加了pattern正则表达式校验：1&lt;input type="text" autofocus="autofocus" required pattern="\d+"/&gt; 另外一个较大的改进就是增加了form属性，也就是说，任何一个标签都可以指定它所属于一个表单，而不是必须在 中进行包裹了。1&lt;input type="text" form="demoform" name="demo"/&gt; 2. form表单新增加的属性 novalidate属性规定在提交表单时不应该验证 form 或input域 autocomplete属性规定form或input域应该拥有自动完成功能 1&lt;form action="" method="POST" novalidate="true"&gt;&lt;/form&gt; 三、综合实例12345678910111213141516171819&lt;fieldset&gt; &lt;legend&gt;表单演示：最新Opera浏览器支持效果良好&lt;/legend&gt; &lt;form action="" method="POST" id="form1" oninput="output.value=parseInt(range.value)"&gt; &lt;input type="text" autofocus="autofocus" required pattern="\d+" name="auto" placeholder="必填项测试" /&gt; &lt;input type="number" name="demoNumber" min="1" max="100" step="2" /&gt; &lt;input type="email" placeholder="请输入邮箱" name="mail" /&gt; &lt;input type="url" name="url" placeholder="输入正确的网址" /&gt; &lt;br /&gt; 日期：&lt;input type="datetime" name="time" /&gt; 颜色：&lt;input type="color" name="color" /&gt;&lt;br /&gt; &lt;br /&gt; &lt;input type="range" min="0" max="50" step="5" name="range" value="0" /&gt; &lt;output name="output"&gt;0&lt;/output&gt; &lt;br /&gt; &lt;input type="submit" value="提交表单" /&gt; &lt;/form&gt; 表单外的input标签： &lt;input type="text" form="form1" name="demo" /&gt;&lt;/fieldset&gt;]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>HTML5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于Canvas的一些参数]]></title>
    <url>%2F2017%2F03%2F27%2Fcanvas-property%2F</url>
    <content type="text"><![CDATA[一、Canvas Canvas就是一个画布，可以进行画任何的线、图形、填充等一系列的操作，而且操作的画图就是js，所以让js编程到了嗑药的地步。另外Canvas不仅仅提供简单的二维矢量绘图，也提供了三维的绘图，以及图片处理等一系列的api支持。 二、Canvas中的Context 要使用Canvas来绘制图形必须在页面中添加Canvas的标签12345&lt;canvas id="demoCanvas" width="500" height="500"&gt;&lt;p&gt; 请使用支持HTML5的浏览器查看本实例&lt;/p&gt;&lt;/canvas&gt; 只有上面的标签，只能是创建好了一个画布，其中width 和height 属性就是设置画布的大小。Id属性也是必须的，后面要用Id来拿到当前的 Canvas 的Dom对象。通过此 Canvase 的Dom对象就可以获取他的上下文 （Context） 了， Canvas 绘制图形都是靠着 Canvas 对象的上下文对象 123456&lt;script type="text/javascript"&gt;//第一步：获取canvas元素var canvasDom = document.getElementById("demoCanvas");//第二步：获取上下文var context = canvasDom.getContext('2d');&lt;/script&gt; Context上下文默认两种绘制方式： 第一种：绘制线（stroke） 第二种：填充（fill） 三、Canvas绘制立体透明矩形 1. Canvas绘制步骤： 创建HTML页面，设置画布标签 编写js，获取画布dom对象 通过canvas标签的Dom对象获取上下文 设置绘制样式、颜色 绘制矩形，或者填充矩形 12345678910111213141516171819&lt;body&gt; &lt;canvas id="demoCanvas" width="500" height="500"&gt; &lt;p&gt;请使用支持HTML5的浏览器查看本实例&lt;/p&gt; &lt;/canvas&gt; &lt;!---下面将演示一种绘制矩形的demo---&gt; &lt;script type="text/javascript"&gt; //第一步：获取canvas元素 var canvasDom = document.getElementById("demoCanvas"); //第二步：获取上下文 var context = canvasDom.getContext('2d'); //第三步：指定绘制线样式、颜色 context.strokeStyle = "red"; //第四步：绘制矩形，只有线。内容是空的 context.strokeRect(10, 10, 190, 100); //以下演示填充矩形。 context.fillStyle = "blue"; context.fillRect(110,110,100,100); &lt;/script&gt;&lt;/body&gt; 四、Canvas绘制线条 Context 对象的 beginPath 方法表示开始绘制路径，moveTo(x, y)方法设置线段的起点，lineTo(x, y)方法设置线段的终点，stroke方法用来给透明的线段着色。moveto和lineto方法可以多次使用。最后，还可以使用closePath方法，自动绘制一条当前点到起点的直线，形成一个封闭图形，省却使用一次lineto方法。123456789101112131415161718&lt;body&gt; &lt;canvas id="demoCanvas" width="500" height="600"&gt; &lt;/canvas&gt; &lt;script type="text/javascript"&gt; //通过id获得当前的Canvas对象 var canvasDom = document.getElementById("demoCanvas"); //通过Canvas Dom对象获取Context的对象 var context = canvasDom.getContext("2d"); context.beginPath(); // 开始路径绘制 context.moveTo(20, 20); // 设置路径起点，坐标为(20,20) context.lineTo(200, 200); // 绘制一条到(200,20)的直线 context.lineTo(400, 20); context.closePath(); context.lineWidth = 2.0; // 设置线宽 context.strokeStyle = "#CC0000"; // 设置线的颜色 context.stroke(); // 进行线的着色，这时整条线才变得可见 &lt;/script&gt;&lt;/body&gt; 五、Canvas绘制文本 Context上下文对象的fillText(string, x, y)方法是用来绘制文本，它的三个参数分别为文本内容、起点的x坐标、y坐标。使用之前，需用font设置字体、大小、样式（写法类似与CSS的font属性）。与此类似的还有strokeText方法，用来添加空心字。 另外注意一点：fillText方法不支持文本断行，即所有文本出现在一行内。所以，如果要生成多行文本，只有调用多次fillText方法。 123456789101112131415161718&lt;canvas id="demoCanvas" width="500" height="600"&gt;&lt;/canvas&gt;&lt;script type="text/javascript"&gt; //通过id获得当前的Canvas对象 var canvasDom = document.getElementById("demoCanvas"); //通过Canvas Dom对象获取Context的对象 var context = canvasDom.getContext("2d"); context.moveTo(200,200); // 设置字体 context.font = "Bold 50px Arial"; // 设置对齐方式 context.textAlign = "left"; // 设置填充颜色 context.fillStyle = "#005600"; // 设置字体内容，以及在画布上的位置 context.fillText("老马!", 10, 50); // 绘制空心字 context.strokeText("blog.itjeek.com!", 10, 100);&lt;/script&gt; 六、Canvas绘制圆形和椭圆 Context上下文的arc方法就是绘制圆形或者椭圆，arc方法的x和y参数是圆心坐标，radius是半径，startAngle和endAngle则是扇形的起始角度和终止角度（以弧度表示），anticlockwise表示做图时应该逆时针画（true）还是顺时针画（false）。 12345678910111213&lt;canvas id="demoCanvas" width="500" height="600"&gt;&lt;/canvas&gt;&lt;script type="text/javascript"&gt; //通过id获得当前的Canvas对象 var canvasDom = document.getElementById("demoCanvas"); //通过Canvas Dom对象获取Context的对象 var context = canvasDom.getContext("2d"); context.beginPath();//开始绘制路径 //绘制以 （60,60）为圆心，50为半径长度，从0度到360度（PI是180度），最后一个参数代表顺时针旋转。 context.arc(60, 60, 50, 0, Math.PI * 2, true); context.lineWidth = 2.0;//线的宽度 context.strokeStyle = "#000";//线的样式 context.stroke();//绘制空心的，当然如果使用fill那就是填充了。&lt;/script&gt; 七、Canvas绘制图片 Canvas绘制图片应该是他的一大特点或者是亮点吧。当然配合File的API，让JS变得无可匹敌。那接下里给大家演示一下怎样绘制图片，并且做出一个立体效果出来。123456789101112131415&lt;canvas id="demoCanvas" width="500" height="600"&gt;&lt;/canvas&gt;&lt;script type="text/javascript"&gt; //通过id获得当前的Canvas对象 var canvasDom = document.getElementById("demoCanvas"); //通过Canvas Dom对象获取Context的对象 var context = canvasDom.getContext("2d"); var image = new Image();//创建一张图片 image.src = "Images/a.png";//设置图片的路径 image.onload = function() &#123;//当图片加载完成后 for (var i = 0; i &lt; 10; i++) &#123;//输出10张照片 //参数：（1）绘制的图片 （2）坐标x，（3）坐标y context.drawImage(image, 100 + i * 80, 100 + i * 80); &#125; &#125;;&lt;/script&gt;]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>canvas</tag>
        <tag>参数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML5中的新结构标签]]></title>
    <url>%2F2017%2F03%2F27%2Fh5-newTitle%2F</url>
    <content type="text"><![CDATA[示例图 传统 HTML5 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;my page&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;header&gt;header&lt;/header&gt; &lt;nav&gt;nav&lt;/nav&gt; &lt;article&gt; &lt;section&gt;section&lt;/section&gt; &lt;/article&gt; &lt;aside&gt;aside&lt;/aside&gt; &lt;footer&gt;footer&lt;/footer&gt; &lt;/body&gt;&lt;/html&gt; section定义文档中的节。它用来表现普通的文档内容或应用区块。但section元素标签并非一个普通的容器元素，它表示一段专题性的内容，一般会带有标题。 123456789&lt;section&gt; &lt;h1&gt;section是什么？&lt;/h1&gt; &lt;h2&gt;一个新章节&lt;/h2&gt; &lt;article&gt; &lt;h2&gt;关于section&lt;/h2&gt; &lt;p&gt;section的介绍&lt;/p&gt; ... &lt;/article&gt;&lt;/section&gt; article特殊的 section 标签，它比 section 具有更明确的语义，它代表一个独立的、完整的相关内容块。当我们描述一件具体的事物的时候，通常鼓励使用 article 来代替 section 。 article 会有标题部分（通常包含在header内），也可以包含 footer。 article 可以嵌套，内层的 article 对外层的 article 标签有隶属关系。 12345678910&lt;article&gt; &lt;header&gt; &lt;hgroup&gt; &lt;h1&gt;这是一篇介绍HTML 5结构标签的文章&lt;/h1&gt; &lt;h2&gt;HTML 5的革新&lt;/h2&gt; &lt;/hgroup&gt; &lt;time datetime="2011-03-20"&gt;2011.03.20&lt;/time&gt; &lt;/header&gt; &lt;p&gt;文章内容详情&lt;/p&gt;&lt;/article&gt; nav可以作为页面导航的链接组，其中的导航元素链接到其它页面或者当前页面的其他部分，是html代码在语义化方面更加精确，同事对于屏幕阅读器等设备的支持也更好。 1234567&lt;nav&gt; &lt;ul&gt; &lt;li&gt;厚德IT&lt;/li&gt; &lt;li&gt;FlyDragon&lt;/li&gt; &lt;li&gt;J飞龙天惊&lt;/li&gt; &lt;/ul&gt;&lt;/nav&gt; asideaside 标签用来装载非正文的内容，被视为页面里面一个单独的部分。它包含的内容与页面的主要内容是分开的，可以被删除，而不会影响到网页的内容、章节或是页面传达的信息。例如广告，成组的链接，侧边栏等等。 1234&lt;aside&gt; &lt;h1&gt;作者简介&lt;/h1&gt; &lt;p&gt;厚德IT&lt;/p&gt;&lt;/aside&gt; headerheader 标签定义文档的页眉，通常是一些引导和导航信息。它不局限于写在网页的头部，也可以写在网页的内容里面。 通常header 标签至少包含一个标记（h1 - h6 ），还可以包括hgroup 标签，还可以包括表格内容、标识、搜索表单、nav 导航等。 123456&lt;header&gt; &lt;hgroup&gt; &lt;h1&gt;网站标题&lt;/h1&gt; &lt;h1&gt;网站副标题&lt;/h1&gt; &lt;/hgroup&gt;&lt;/header&gt; footerfooter 标签定义section 或document 的页脚，包含了与页面、文章或是部分内容有关的信息，比如说文章的作者或者日期。它和header 标签使用基本一样，可以在一个页面中多次使用，如果在一个区段的后面加入footer ，那么它就相当于该区段的页脚了。123456&lt;header&gt; &lt;hgroup&gt; &lt;h1&gt;网站标题&lt;/h1&gt; &lt;h1&gt;网站副标题&lt;/h1&gt; &lt;/hgroup&gt;&lt;/header&gt; hgrouphgroup 标签是对网页或区段section 的标题元素（h1 - h6 ）进行组合。例如，在一区段中你又连续的h系列的标签元素，则可以用hgroup 将他们括起来。1234&lt;hgroup&gt; &lt;h1&gt;这是一篇介绍HTML 5结构标签的文章&lt;/h1&gt; &lt;h2&gt;HTML 5的革新&lt;/h2&gt;&lt;/hgroup&gt; fivure用于对元素进行组合。多用于图片于图片描述组合。 1234&lt;figure&gt; &lt;img src="img.gif" alt="figure标签" title="figure标签" /&gt; &lt;figcaption&gt;这儿是图片的描述信息&lt;/figcaption&gt;&lt;/figure&gt;]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>HTML5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ajax学习小记-概念]]></title>
    <url>%2F2017%2F03%2F27%2Fajax-note%2F</url>
    <content type="text"><![CDATA[异步通过 XMLHttpRequest 函数来实现客户端和服务器端的异步处理 具体实现： 运用HTML和CSS来实现页面，表达信息； 运用XMLHttpRequest和Web服务器进行数据的异步交换； 运用JavaScript操作DOM，实现动态局部刷新； XMLHttpREquest对象 不兼容IE6123456var request;if (window.XMLHttpRequest) &#123; request = new XMLHttprequest();//IE7+,chrome,ff,safari.&#125; else &#123; request = new ActiveXobject('Microsoft.XmlHTTP');??&#125; HTTP请求HTTP请求过程 建立TCP连接 Web浏览器向Web服务器发送请求命令 Web浏览器发送请求头信息 Web服务器应答 Web服务器发送应答头信息 Web服务器向浏览器发送数据 Web服务器关闭TCP连接 HTTP组成部分 HTTP请求的方法或动作，比如是GET还是POST请求 正在请求的URL 请求头（如客户端环境信息，身份验证信息） 请求体，也就是请求 正文，请求好着呢个文中可以包含客户提交的 查询字符串信息，表单信息等等。 重点概念 GET： 一般用信息获取 使用URL传递参数 对所发送信息的数量也有 POST： 一半用于修改服务器上的资源 对所发送的信息数量无限制 响应组成： 数字文字的状态码，显示请求的成功和失败 响应头 响应体 HTTP状态码 1XX：信息类，表示收到浏览器请求，正在处理 2XX: 成功，正确接受 3XX：重定向，请求失败 4XX：客户端错误，如 404 NOT 5XX：服务器错误，如 500 XMLHttpRequest发送请求： open(method,url,async) method：规定HTTP发送请求的方式是get还是post,不区分大小写，一般来说用大写 url：请求地址(相对地址或绝对地址) async:同步/异步(false/true)，默认是异步也就是true，可以不用填写 send(string): 发送到服务器（该参数可以填或者不填—–get方法不填或填null，post:一般要填） XMLHttpRequest取得响应 responseText:获得字符串形式的响应数据 responseXML：获得XML形式的响应数据（比较少） status和statusText:以数字和文本形式返回HTTP状态码 getAllResponseHeader()：获取所有的响应报头 getResponseHeader()：查询响应中的某个字段的值 readyState属性的变化代表服务器响应的变化 请求未初始化，open还没有调用 服务器连接已建立，open已经调用了 请求已接收，也就是接收到头信息了 请求处理中，也就是接收到了响应主体 请求已完成，且响应已就绪，也就是响应完成了]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Ajax</tag>
        <tag>慕课网</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[慕课网-人机大战五子棋AI篇学习笔记]]></title>
    <url>%2F2017%2F03%2F27%2Fgo-bang%2F</url>
    <content type="text"><![CDATA[创建赢法数组 先贴出第一步代码 1234567var wins = [];for(let i=0 ; i &lt; 15 ; i++ ) &#123; wins[i] = []; for(let j = 0; j&lt;15; j++) &#123; wins[i][j] = []; &#125;&#125; 这段代码仅仅只是创了一个准备用于记录所有赢法的三维空数组。 接下来第二部就是建立赢法数组，复制并建立索引。代码：竖排123456789var count = 0;for(let i=0; i&lt; 15 ;i++) &#123; for(let j=0;j&lt;11 ;j++) &#123; for(let k=0;k&lt;5;k++) &#123; wins[i][j+k][count] = true; &#125; count++; &#125;&#125; 本段代码的含义就是遍历了所有竖排列中存在的赢的组合，count为每一种赢法所对应的唯一索引。例如：12345wins[0][0][0] = true;wins[0][1][0] = true;wins[0][2][0] = true;wins[0][3][0] = true;wins[0][4][0] = true; 就是意味着我们将第一竖排前五个空格连成一线的赢法都列举出来，并给每一个格子赋值为true、给出的索引为count = 0（即第三维数组）。 同理，很容易可以写出遍历横排，45°角和135°角排列上的代码： 横排12345678910var count = 0;for(let i=0; i&lt; 15 ;i++) &#123; for(let j=0;j&lt;11 ;j++) &#123; for(let k=0;k&lt;5;k++) &#123; wins[j+k][i][count] = true; &#125; count++; &#125;&#125; 45°12345678910var count = 0;for(let i=0; i&lt; 11 ;i++) &#123; for(let j=0;j&lt;11 ;j++) &#123; for(let k=0;k&lt;5;k++) &#123; wins[i+k][j+k][count] = true; &#125; count++; &#125;&#125; 135°12345678910var count = 0;for(let i=0; i&lt; 11 ;i++) &#123; for(let j=14;j&gt;3 ;j++) &#123; for(let k=0;k&lt;5;k++) &#123; wins[i+k][j-k][count] = true; &#125; count++; &#125;&#125; 相较于较为抽象的描述，还是图来的简单明了。 输赢判断慕课网将其称为赢法统计，我总觉得过于抽象了。让我来理解，说是输赢判断，或者说是迈向胜利的进度，更加容易理解。代码：1234567var myWin = [];//我方胜利进度（黑子）var coumputerWin = [];//电脑方胜利进度(白子)for(let i = 0;i &lt; count ; i++) &#123; myWin[i] = 0; coumputerWin[i] = 0;&#125; 首相遍历count，两方胜利进度数组都赋值为0。 然后就要修改落子时的onclick事件的判定条件。12345678910111213141516171819202122232425262728293031var over = false;//判断棋局是否结束chess.onclick = function(e) &#123; if(over) &#123; return; &#125; var x = e.offsetX; var y = e.offsetY; var i= Math.floor(x/30); var j = Math.floor(y/30); if(hascheer[i][j] == 0) &#123; oneStep(i,j,me); if(me) &#123; hascheer[i][j] = 1; &#125;else &#123; hascheer[i][j] = 2; &#125; me = !me; //本次操作添加代码 for(let k= 0;k&lt;count; k++) &#123; if(wins[i][j][k]) &#123; myWin[k] ++; pcWin = 6;//当有一方占据了当前赢法数组中的一格，即可判定为另一方在该赢法数组条件下已不可能获胜，抛出异常数值。 if(myWin[k] == 5) &#123; window.alert(&quot;你赢了!&quot;); &#125; &#125; &#125; &#125;&#125; 前面的代码是UI篇当中的。关于输赢判断，思路是在onclick事件下，每次落子，遍历count,并对落子坐标i,j所对应的赢法k胜利进度+1，胜利进度=5的时候，就代表在这一赢法下获胜了。 例如，在wins[0][0][k]的情况下，其实只有三种赢法，即向右五格，向下五格以及45°角五格，因此，当k不等于这三种赢法的索引时，myWins[k]就不会自加，即该赢法进度没有变化。PS：后面要做computer自动下子，所以这里只写了黑子的判定。 AI实现代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100var pcAI = function() &#123; //玩家分数 let myScore = [],// 电脑分数 pcScore = [],// 最优位置的分数 max = 0,// 电脑预落子maxI列 maxI = 0,// 电脑预落子maxJ行 maxJ =0; for (let i=0;i&lt;15;i++) &#123; myScore[i] = []; pcScore[i] = []; for(let j=0; j&lt;15;j++) &#123; myScore[i][j] = 0; pcScore[i][j] = 0; &#125; &#125;// 对两个数组分别进行加分 for (let i=0;i&lt;15;i++) &#123; for(let j=0;j&lt;15;j++) &#123; if(hasChess[i][j] == 0) &#123; for (let k=0;k&lt;count;k++)&#123; if(wins[i][j][k]) &#123; switch(myWin[k]) &#123; case 1: myScore[i][j] +=200; break; case 2: myScore[i][j] +=400; break; case 3: myScore[i][j] +=2000; break; case 4: myScore[i][j] +=10000; break; default: break; &#125; switch(pcWin[k]) &#123; case 1: pcScore[i][j] +=220; break; case 2: pcScore[i][j] +=420; break; case 3: pcScore[i][j] +=2220; break; case 4: pcScore[i][j] +=20000; break; case 6: pcScore[i][j] = 0; break; default: break; &#125; &#125; &#125;// 若玩家在(i,j)处的分数高于目前的最高分数,则落子在(i,j)处 if(myScore[i][j] &gt; max) &#123; max = myScore[i][j]; maxI = i; maxJ = j; &#125;else if(myScore[i][j] == max&amp;&amp; pcScore[i][j] &gt; pcScore[maxI][maxJ])&#123; // 如果玩家(i,j)处和目前最优分数一样大，则比较电脑在该位置和预落子的位置的分数 maxI = i; maxJ = j; &#125;// 如果电脑(i,j)处比目前最优的分数大，则落子在(i,j)处 if(pcScore[i][j] &gt; max) &#123; max = pcScore[i][j]; maxI = i; maxJ = j; &#125;else if(pcScore[i][j] == max &amp;&amp; myScore[i][j] &gt; myScore[maxI][maxJ])&#123;// 如果电脑(i,j)处和目前最优分数一样大，则比较玩家在该位置和预落子的位置的分数 maxI = i; maxJ = j; &#125; &#125; &#125;; &#125; oneStep(maxI,maxJ,false); hasChess[maxI][maxJ] = 2; for (let n=0 ; n&lt;count;n++) &#123; if(wins[maxI][maxJ][n]) &#123; pcWin[n]++; myWin[n] =6; if(pcWin[n] == 5) &#123; window.alert("你输了！"); over = true; &#125; &#125; &#125;&#125; 很复杂的代码。通过遍历坐标，确定包含这个坐标的赢法，然后对这个赢法进行权重加成，赢法内拥有越多的黑子，权重越大。同时，对自己下子的每个坐标所对应的的赢法也进行加权，并且电脑获胜是的权重是高于人的。（这里很难用自己的话描述出来）。以图为例： 当黑子落点为坐标[0][0]时，此时应当是有三个方向上，即横、竖、45°，三个赢法数组存在。并且所对应的元素均为true。黑子落点后，上面代码中的第一次循环因为if(hasCheer[0][0])为false，跳过，三种赢法内空余的格子都进入循环，每种myWin[k]都是一，所以横、竖、45°线上其他空格的分数均为200，因此第一次循环获取到坐标i=0,j=之后，后面的因为都与它相等不会获得更高权重，所以AI会落子在0,1处。 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231//canvasvar gobang = document.getElementById("gobang"), context = gobang.getContext("2d"), background = new Image(); background.src = "img/bg.png";context.strokeStyle = "#000";background.onload = function() &#123; context.drawImage(background,0,0,450,450); (() =&gt; &#123; for (let i= 0; i&lt;15 ; i++ ) &#123; context.moveTo(15 + i*30, 15); context.lineTo(15 + i*30, 435); context.stroke(); context.moveTo(15,15 + i*30); context.lineTo(435,15+ i*30); context.stroke(); &#125; &#125;)();&#125;//落子var hasChess = [], me = true;for (let i=0; i&lt;15; i++) &#123; hasChess[i] = []; for (let j=0; j&lt;15;j++) &#123; hasChess[i][j] = 0; &#125;&#125;var oneStep = function (i,j,me) &#123; context.beginPath(); context.arc(15 + i*30,15 + j*30,13,0,2*Math.PI); context.closePath(); let gradient = context.createRadialGradient(15 + i*30, 15+ j*30 -2,50,15 + i*30 +2, 15+j * 30 - 2,0); me ? (()=&gt;&#123;gradient.addColorStop(0,"#0a0a0a");gradient.addColorStop(1,"#8e8e8e" )&#125;)() : (()=&gt;&#123;gradient.addColorStop(0,"#8e8e8e");gradient.addColorStop(1,"#fff")&#125;)(); context.fillStyle = gradient; context.fill(); me = !me;&#125;//赢法数组var wins = [], count = 0; //生产赢法数组for (let i=0;i&lt;15 ; i ++) &#123; wins[i] = []; for(let j = 0; j&lt;15;j ++) &#123; wins[i][j] = []; &#125;&#125;//所有竖排赢法for (let i=0; i&lt;15; i++) &#123; for(let j=0;j&lt;11;j++) &#123; for (let k=0;k&lt;5;k++) &#123; wins[i][j+k][count] = true; &#125; count++; &#125;&#125;//所有横排赢法for (let i=0; i&lt;15;i++) &#123; for (let j = 0;j&lt;11;j ++) &#123; for (let k=0;k&lt;5;k++) &#123; wins[j+k][i][count] = true; &#125; count++; &#125;&#125;//所有45°赢法for (let i=0;i&lt;11;i++) &#123; for(let j=0;j&lt;11;j++) &#123; for(let k=0;k&lt;5;k++) &#123; wins[i+k][j+k][count] = true; &#125; count++; &#125;&#125;//所有135°赢法for (let i=0; i&lt;11;i++) &#123; for(let j=14;j&gt;3;j--) &#123; for (let k=0;k&lt;5;k++) &#123; wins[i+k][j-k][count] = true; &#125; count++; &#125;&#125;//输赢判断var myWin = [], pcWin = [], over = false;for(let i=0;i&lt;count ;i++) &#123; myWin[i] = 0; pcWin[i] = 0;&#125;//AI实现var pcAI = function() &#123; //玩家分数 let myScore = [],// 电脑分数 pcScore = [],// 最优位置的分数 max = 0,// 电脑预落子maxI列 maxI = 0,// 电脑预落子maxJ行 maxJ =0; for (let i=0;i&lt;15;i++) &#123; myScore[i] = []; pcScore[i] = []; for(let j=0; j&lt;15;j++) &#123; myScore[i][j] = 0; pcScore[i][j] = 0; &#125; &#125;// 对两个数组分别进行加分 for (let i=0;i&lt;15;i++) &#123; for(let j=0;j&lt;15;j++) &#123; if(hasChess[i][j] == 0) &#123; for (let k=0;k&lt;count;k++)&#123; if(wins[i][j][k]) &#123; switch(myWin[k]) &#123; case 1: myScore[i][j] +=200; break; case 2: myScore[i][j] +=400; break; case 3: myScore[i][j] +=2000; break; case 4: myScore[i][j] +=10000; break; default: break; &#125; switch(pcWin[k]) &#123; case 1: pcScore[i][j] +=220; break; case 2: pcScore[i][j] +=420; break; case 3: pcScore[i][j] +=2220; break; case 4: pcScore[i][j] +=20000; break; case 6: pcScore[i][j] = 0; break; default: break; &#125; &#125; &#125;// 若玩家在(i,j)处的分数高于目前的最高分数,则落子在(i,j)处 if(myScore[i][j] &gt; max) &#123; max = myScore[i][j]; maxI = i; maxJ = j; &#125;else if(myScore[i][j] == max&amp;&amp; pcScore[i][j] &gt; pcScore[maxI][maxJ])&#123; // 如果玩家(i,j)处和目前最优分数一样大，则比较电脑在该位置和预落子的位置的分数 maxI = i; maxJ = j; &#125;// 如果电脑(i,j)处比目前最优的分数大，则落子在(i,j)处 if(pcScore[i][j] &gt; max) &#123; max = pcScore[i][j]; maxI = i; maxJ = j; &#125;else if(pcScore[i][j] == max &amp;&amp; myScore[i][j] &gt; myScore[maxI][maxJ])&#123;// 如果电脑(i,j)处和目前最优分数一样大，则比较玩家在该位置和预落子的位置的分数 maxI = i; maxJ = j; &#125; &#125; &#125;; &#125; oneStep(maxI,maxJ,false); hasChess[maxI][maxJ] = 2; for (let n=0 ; n&lt;count;n++) &#123; if(wins[maxI][maxJ][n]) &#123; pcWin[n]++; myWin[n] =6; if(pcWin[n] == 5) &#123; window.alert("你输了！"); over = true; &#125; &#125; &#125;&#125;gobang.onclick = function(e) &#123; if (over) &#123; return; &#125; if (!me) &#123; return; &#125; let x = e.offsetX, y = e.offsetY, i = Math.floor(x/30), j = Math.floor(y/30); if (hasChess[i][j] == 0 ) &#123; oneStep(i,j,me); hasChess[i][j] = 1; for (let k=0; k&lt;count;k++) &#123; if(wins[i][j][k]) &#123; myWin[k]++; pcWin[k] =6; if(myWin[k] == 5) &#123; window.alert("你赢了！"); over = true; &#125; &#125; &#125; if(!over) &#123; pcAI(); &#125; &#125;&#125;]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>慕课网</tag>
        <tag>五子棋</tag>
      </tags>
  </entry>
</search>