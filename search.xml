<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[FCC高级算法题]]></title>
      <url>%2F2017%2F03%2F29%2Ffcc-senior%2F</url>
      <content type="text"><![CDATA[Validate US Telephone Numbers如果传入字符串是一个有效的美国电话号码，则返回 true. 用户可以在表单中填入一个任意有效美国电话号码. 下面是一些有效号码的例子(还有下面测试时用到的一些变体写法):555-555-5555(555)555-5555(555) 555-5555555 555 555555555555551 555 555 5555在本节中你会看见如 800-692-7753 or 8oo-six427676;laskdjf这样的字符串. 你的任务就是验证前面给出的字符串是否是有效的美国电话号码. 区号是必须有的. 如果字符串中给出了国家代码, 你必须验证其是 1. 如果号码有效就返回 true ; 否则返回 false. 12345function telephoneCheck(str) &#123; var reg=/^1? ?(\d&#123;3&#125;|\(\d&#123;3&#125;\))[ -]?\d&#123;3&#125;[ -]?\d&#123;4&#125;$/; var res=reg.test(str); return res;&#125; Symmetric Difference创建一个函数，接受两个或多个数组，返回所给数组的 对等差分(symmetric difference) (△ or ⊕)数组. 给出两个集合 (如集合 A = {1, 2, 3} 和集合 B = {2, 3, 4}), 而数学术语 “对等差分” 的集合就是指由所有只在两个集合其中之一的元素组成的集合(A △ B = C = {1, 4}). 对于传入的额外集合 (如 D = {2, 3}), 你应该安装前面原则求前两个集合的结果与新集合的对等差分集合 (C △ D = {1, 4} △ {2, 3} = {1, 2, 3, 4}). 1234567891011121314151617181920212223242526272829function sym(args) &#123; var newArgs = Array.prototype.slice.call(arguments);//转化数组 function diff(arr1,arr2)&#123; //闭包函数 arr1 = Array.from(new Set(arr1)); arr2 = Array.from(new Set(arr2));//对参数进行去重 var counter = arr2.length; for(i = 0;i&lt;arr1.length;i++)&#123; counter --; arr2 = arr2.filter(function(val)&#123; return val !== arr1[i]; &#125;);//遍历arr2，并返回arr2不与arr1重复的元素 if(counter&lt;arr2.length)&#123; arr2.push(arr1[i]);//将arr1中不与arr2重复的元素添加进arr2中 counter = arr2.length; &#125;else&#123; continue; &#125; &#125; return arr2; &#125; for(x = 0;x&lt;newArgs.length-1;x++)&#123; newArgs[x+1] = diff(newArgs[x],newArgs[x+1]);//对newArgs数组进行遍历 &#125; return newArgs[newArgs.length-1];&#125;sym([1, 1, 2, 5], [2, 2, 3, 5], [3, 4, 5, 5]); Exact Change设计一个收银程序 checkCashRegister() ，其把购买价格(price)作为第一个参数 , 付款金额 (cash)作为第二个参数, 和收银机中零钱 (cid) 作为第三个参数. cid 是一个二维数组，存着当前可用的找零. 当收银机中的钱不够找零时返回字符串 “Insufficient Funds”. 如果正好则返回字符串 “Closed”. 否则, 返回应找回的零钱列表,且由大到小存在二维数组中. 本题代码来自fcc的wiki 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354var denom = [ &#123; name: 'ONE HUNDRED', val: 100.00&#125;, &#123; name: 'TWENTY', val: 20.00&#125;, &#123; name: 'TEN', val: 10.00&#125;, &#123; name: 'FIVE', val: 5.00&#125;, &#123; name: 'ONE', val: 1.00&#125;, &#123; name: 'QUARTER', val: 0.25&#125;, &#123; name: 'DIME', val: 0.10&#125;, &#123; name: 'NICKEL', val: 0.05&#125;, &#123; name: 'PENNY', val: 0.01&#125;];function checkCashRegister(price, cash, cid) &#123; var change = cash - price;// 遍历cid数组获得一个带有目前零钱总数和各零钱数额的register对象 var register = cid.reduce(function(acc, curr) &#123; acc.total += curr[1]; acc[curr[0]] = curr[1]; return acc; &#125;, &#123;total: 0&#125;);//零钱正好找完 if (register.total === change) &#123; return 'Closed'; &#125;// 零钱不够了 if (register.total &lt; change) &#123; return 'Insufficient Funds'; &#125;// 遍历denom数组 var change_arr = denom.reduce(function(acc, curr) &#123; var value = 0; // while该面值零钱仍有余额 // 面值应当小于或等于找零 while (register[curr.name] &gt; 0 &amp;&amp; change &gt;= curr.val) &#123; change -= curr.val; register[curr.name] -= curr.val; value += curr.val;// 消除浮点数误差 change = Math.round(change * 100) / 100; &#125; if (value &gt; 0) &#123; acc.push([ curr.name, value ]); &#125; return acc; &#125;, []); // Initial value of empty array for reduce// change_arr数组若没有元素或者无法找尽零钱，返回零钱不够了 if (change_arr.length &lt; 1 || change &gt; 0) &#123; return "Insufficient Funds"; &#125;// Here is your change, ma'am. return change_arr;&#125;// test herecheckCashRegister(19.50, 20.00, [["PENNY", 1.01], ["NICKEL", 2.05], ["DIME", 3.10], ["QUARTER", 4.25], ["ONE", 90.00], ["FIVE", 55.00], ["TEN", 20.00], ["TWENTY", 60.00], ["ONE HUNDRED", 100.00]]); Inventory Update依照一个存着新进货物的二维数组，更新存着现有库存(在 arr1 中)的二维数组. 如果货物已存在则更新数量 . 如果没有对应货物则把其加入到数组中，更新最新的数量. 返回当前的库存数组，且按货物名称的字母顺序排列. 12345678910111213141516171819202122function updateInventory(arr1, arr2) &#123; arr1.forEach(function(v,ind,a)&#123; for(i=0;i&lt;arr2.length;i++)&#123; if(arr2[i][1] == v[1])&#123; v[0] +=arr2[i][0]; &#125; &#125; &#125;); for(i=0;i&lt;arr1.length;i++)&#123; arr2 = arr2.filter(function(val)&#123; return val[1] !== arr1[i][1]; &#125;); &#125; var newArr = arr1.concat(arr2); newArr.sort(function(a,b)&#123; return a[1].charCodeAt(0)-b[1].charCodeAt(0); &#125;); return newArr;&#125;// Example inventory listsupdateInventory([[21, "Bowling Ball"], [2, "Dirty Sock"], [1, "Hair Pin"], [5, "Microphone"]], [[2, "Hair Pin"], [3, "Half-Eaten Apple"], [67, "Bowling Ball"], [7, "Toothpaste"]]); No repeats please把一个字符串中的字符重新排列生成新的字符串，返回新生成的字符串里没有连续重复字符的字符串个数.连续重复只以单个字符为准 例如, aab 应该返回 2 因为它总共有6中排列 (aab, aab, aba, aba, baa, baa), 但是只有两个 (aba and aba)没有连续重复的字符 (在本例中是 a). 123456789101112131415161718192021222324function permAlone(str) &#123; var reg = /(.)\1+/g;//正则 var newArr = str.split(''); var r = []; var num = str.length; (function f(t,a,n)&#123; if(n===0)&#123; return r.push(t); &#125; for(var i=0;i&lt;a.length;i++)&#123; f(t.concat(a[i]),a.slice(0,i).concat(a.slice(i+1)),n-1); &#125; &#125;)([],newArr,num);//对数组进行全排列 var res = r.map(function(val)&#123; return val.join(''); &#125;); res = res.filter(function(val)&#123; return !val.match(reg); &#125;);//匹配正则 return res.length;&#125;permAlone('aab'); Friendly Date Ranges让日期区间更友好！ 把常见的日期格式如：YYYY-MM-DD 转换成一种更易读的格式。 易读格式应该是用月份名称代替月份数字，用序数词代替数字来表示天 (1st 代替 1). 记住不要显示那些可以被推测出来的信息: 如果一个日期区间里结束日期与开始日期相差小于一年，则结束日期就不用写年份了。月份开始和结束日期如果在同一个月，则结束日期月份就不用写了。 另外, 如果开始日期年份是当前年份，且结束日期与开始日期小于一年，则开始日期的年份也不用写。 例如: makeFriendlyDates([“2016-07-01”, “2016-07-04”]) 应该返回 [“July 1st”,”4th”] makeFriendlyDates([“2016-07-01”, “2018-07-04”]) 应该返回 [“July 1st, 2016”, “July 4th, 2018”]. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273function makeFriendlyDates(arr) &#123; var Month = ["", "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December" ],//月份转换数组 result = []; function test(dateStr) &#123; dateStr = parseInt(dateStr,10); switch (dateStr) &#123; case 1: dateStr += 'st'; break; case 2: dateStr += 'nd'; break; case 3: dateStr += 'rd'; break; default: dateStr += 'th'; break; &#125; return dateStr;&#125;//日期转换 var date1 = test(arr[0].substr(-2)), date2 = test(arr[1].substr(-2)), arr1 = arr[0].split('-'), arr2 = arr[1].split('-'), year = arr2[0]-arr1[0], month = arr2[1]-arr1[1], date = arr2[2]-arr1[2], month1 = arr[0].substr(5,2), month2 = arr[1].substr(5,2), year1 = arr[0].substr(0,4), year2 = arr[1].substr(0,4); switch(year)&#123; case 0: if(month ==11 &amp;&amp; date == 30)&#123; //同年01-01和12-31 result.push(Month[parseInt(month1,10)]+' '+date1+', '+year1,Month[parseInt(month2,10)]+' '+date2+', '+year2); &#125;else if(month === 0)&#123; if (date !== 0)&#123; //同年同月不同日 result.push(Month[parseInt(month1,10)]+' '+date1,date2); &#125;else&#123; //同年同月同日 result.push(Month[parseInt(month1,10)]+' '+date1+', '+year1); &#125; &#125;else&#123; //同年不同月 result.push(Month[parseInt(month1,10)]+' '+date1+', '+year1,Month[parseInt(month2,10)]+' '+date2); &#125; break; case 1: if((month === 0 &amp;&amp; date == -1)||month &gt;0)&#123; //差一年整 result.push(Month[parseInt(month1,10)]+' '+date1+', '+year1,Month[parseInt(month2,10)]+' '+date2); &#125;else if(month === 0 &amp;&amp; date &gt; -1)&#123; //差一年同月，大于一年 result.push(Month[parseInt(month1,10)]+' '+date1+', '+year1,Month[parseInt(month2,10)]+' '+date2+', '+year2); &#125;else&#123; //差一年，大于一年 result.push(Month[parseInt(month1,10)]+' '+date1,Month[parseInt(month2,10)]+' '+date2); &#125; break; default: result.push(Month[parseInt(month1,10)]+' '+date1+', '+year1,Month[parseInt(month2,10)]+' '+date2+', '+year2);&#125; return result;&#125;makeFriendlyDates(["2018-01-01", "2018-12-31"]); Make a Person用下面给定的方法构造一个对象. 方法有 getFirstName(), getLastName(), getFullName(), setFirstName(first), setLastName(last), and setFullName(firstAndLast). 所有有参数的方法只接受一个字符串参数. 所有的方法只与实体对象交互. 思路比较混乱，首先为了避免后面的代码影响到前面获取名字(get****Name)这几行代码，在更改时尽量将改变的数据存储到函数作用域内声明的变量中。123456789101112131415161718192021222324252627var Person = function(firstAndLast) &#123; var fullName = firstAndLast.split(' '),firstName = fullName[0],lastName = fullName[1]; this.getFirstName = function()&#123; return firstName; &#125;; this.getLastName = function()&#123; return lastName; &#125;; this.getFullName = function()&#123; return firstName+' '+lastName; &#125;; this.setFirstName = function(first)&#123; firstName = first; &#125;; this.setLastName = function(last)&#123; lastName = last; &#125;; this.setFullName = function(firstAndLast)&#123; firstName = firstAndLast.split(' ')[0]; lastName = firstAndLast.split(' ')[1]; &#125;;&#125;;var bob = new Person('Bob Ross');bob.getFullName(); Map the Debris返回一个数组，其内容是把原数组中对应元素的平均海拔转换成其对应的轨道周期. 原数组中会包含格式化的对象内容，像这样 {name: ‘name’, avgAlt: avgAlt}. 至于轨道周期怎么求，戳这里 on wikipedia (不想看英文的话可以自行搜索以轨道高度计算轨道周期的公式). 求得的值应该是一个与其最接近的整数，轨道是以地球为基准的. 地球半径是 6367.4447 kilometers, 地球的GM值是 398600.4418, 圆周率为Math.PI 123456789101112function orbitalPeriod(arr) &#123; var GM = 398600.4418; var earthRadius = 6367.4447, altitude = []; for(var i=0;i&lt;arr.length;i++)&#123; arr[i].orbitalPeriod = Math.round(2*Math.PI*Math.sqrt(Math.pow((earthRadius+arr[i].avgAlt),3)/GM)); delete arr[i].avgAlt; &#125; return arr;&#125;orbitalPeriod([&#123;name : "sputnik", avgAlt : 35873.5553&#125;]); Pairwise（找到你的另一半）都说优秀的程序员擅长面向对象编程，但却经常找不到另一半，这是为什么呢？因为你总是把自己局限成为一个程序员，没有打开自己的思维。 这是一个社群的时代啊，在这里你应该找到与你有相同价值观但又互补的另一半。 譬如：你编程能力强，估值11分，如果以20分为最佳情侣来计算，你应该找一个设计能力强，估值为9分的女生。 那么当你遇到一个设计能力为9分的女生，千万别犹豫，大胆去表白。千万别以为后面的瓜比前面的甜哦。 举个例子：有一个能力数组[7,9,11,13,15]，按照最佳组合值为20来计算，只有7+13和9+11两种组合。而7在数组的索引为0，13在数组的索引为3，9在数组的索引为1，11在数组的索引为2。 所以我们说函数：pairwise([7,9,11,13,15],20) 的返回值应该是0+3+1+2的和，即6。 1234567891011121314function pairwise(arr, arg) &#123; var a = arr.reduce(function(acc,curr,ind,array)&#123; for(var i=ind+1;i&lt;array.length;i++)&#123; if(array[ind] + array[i] == arg)&#123; array[ind] = array[i] = NaN; return acc+i+ind; &#125; &#125; return acc; &#125;,0); return a;&#125;pairwise([1, 3, 2, 4], 4);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[FCC中级算法题]]></title>
      <url>%2F2017%2F03%2F29%2Ffcc-mid%2F</url>
      <content type="text"><![CDATA[Pig Latin 儿童黑话需求：把指定的字符串翻译成 pig latin。Pig Latin 把一个英文单词的第一个辅音或辅音丛（consonant cluster）移到词尾，然后加上后缀 “ay”。如果单词以元音开始，你只需要在词尾添加 “way” 就可以了。见过网上其他人的方法，都是先确定单词内是否具有元音字母，之后还需要你确定是否构成单词。此处，为了简化代码，不做单词的验证，同时，第一次测试将实验直接验证首字母为元音是否可行。12345678910111213141516171819202122232425function translate(str) &#123; var p=/[^aeiou]/; var index=0; //计算出第一个元音字母在字符串中的位置 for(var i=0; i&lt;str.length; i++)&#123; if(p.test(str.charAt(i)))&#123; continue; &#125; index = i; break; &#125; //元音字母为首字母时，给字符串加way后缀 if(index===0)&#123; str+='way'; &#125; //将辅音丛加至结尾,并加上'ay'后缀 else&#123; var arr=str.split(''); var del=arr.splice(0,index); arr=arr.concat(del); str=arr.join('') + 'ay'; &#125; return str;&#125;translate("glove") ; DNA Pairing DNA配对DNA 链缺少配对的碱基。依据每一个碱基，为其找到配对的碱基，然后将结果作为第二个数组返回。Base pairs（碱基对） 是一对 AT 和 CG，为给定的字母匹配缺失的碱基。在每一个数组中将给定的字母作为第一个碱基返回。例如，对于输入的 GCG，相应地返回 [[“G”, “C”], [“C”,”G”],[“G”, “C”]]字母和与之配对的字母在一个数组内，然后所有数组再被组织起来封装进一个数组。1234567891011121314151617function pair(str) &#123; var newArr = str.split(''); for(i=0;i&lt;newArr.length;i++)&#123; switch (newArr[i])&#123; case "G":newArr[i] = newArr[i]+"C";break; case "C":newArr[i] = newArr[i]+"G";break; case "A":newArr[i] = newArr[i]+"T";break; case "T":newArr[i] = newArr[i]+"A";break; &#125; newArr[i] = newArr[i].split(''); &#125; return newArr;&#125;pair("GCG"); Missing letter 消失的字母从传递进来的字母序列中找到缺失的字母并返回它。如果所有字母都在序列中，返回 undefined。 123456789101112131415function fearNotLetter(str) &#123; for(i=0;i&lt;str.length;i++)&#123; var a = str.charCodeAt(i)-str.charCodeAt(i-1); if( a !== 1)&#123; for(j=0;j&lt;a-1;j++)&#123; return String.fromCharCode(str.charCodeAt(i)-1); &#125; &#125; &#125;&#125;fearNotLetter("bcd"); Boo whotype of 12345function boo(bool) &#123; return (typeof bool=='boolean');&#125;boo([1, 2, 3]); Sorted Union写一个 function，传入两个或两个以上的数组，返回一个以给定的原始数组排序的不包含重复值的新数组。换句话说，所有数组中的所有值都应该以原始顺序被包含在内，但是在最终的数组中不包含重复值。非重复的数字应该以它们原始的顺序排序，但最终的数组不应该以数字顺序排序。 本题的思路在于，传入的实参数量是不一定的，因此，不能直接对几个形参使用array.concat();，使用arguments();来获取实参数值。然后进行去重。 12345678910function unite(arr1, arr2, arr3) &#123; var newArr1 = Array.prototype.slice.call(arguments); newArr1 = newArr1.reduce(function(a,b)&#123; return a.concat(b); &#125;); var newArr2 = Array.from(new Set(newArr1)); return newArr2;&#125;unite([1, 3, 2], [5, 2, 1, 4], [2, 1]); Convert HTML Entities将字符串中的字符 &amp;、&lt;、&gt;、” （双引号）, 以及 ‘ （单引号）转换为它们对应的 HTML 实体。 这里需要使用到str.match(),该函数可以返回匹配到的字符 关于正则中的几个修饰符 i：不分大小写 g:匹配所有（否则仅仅匹配一个） m:多行匹配，搭配^和$ 123456789101112131415161718192021function convert(str) &#123; var p = /[&amp;&lt;&gt;"']/g; var HtmlEntities = &#123; '&amp;':'&amp;amp;', '&lt;':'&amp;lt;', '&gt;':'&amp;gt;', "'":"&amp;apos;", '"':'&amp;quot;' &#125;; var arr = str.match(p); if(!arr)&#123; return str; &#125;else&#123; for(i=0;i&lt;arr.length;i++)&#123; str = str.replace(arr[i],HtmlEntities[arr[i]]); &#125; &#125; return str;&#125;convert("Dolce &amp; Gabbana"); Spinal Tap Case将字符串转换为 spinal case。Spinal case 是 all-lowercase-words-joined-by-dashes 这种形式的，也就是以连字符连接所有小写单词。123456789101112131415161718192021222324252627282930313233343536function spinalCase(str) &#123; var newStr = ''; if(str.match(/ /))&#123; for(i=0;i&lt;str.length;i++)&#123; str = str.replace(' ','-'); &#125; return str.toLowerCase();//首先判断，当单词之间有空格时，可直接替换 &#125;else&#123; newStr = str.replace(/[^a-zA-Z]/g,""); var p = /[A-Z]/g; var arr = newStr.match(p); var newArr = newStr.split(''); for(i=0;i&lt;arr.length;i++)&#123; newArr.splice(newStr.indexOf(arr[i]),0,'-');//在每个大写字母前添加"-" newStr = newArr.join('');//由于添加完后的数组已经发生变化，索引和原始字符串不再一致，需要重新定义字符串 /*var a = newStr.indexOf(arr[i]); var b= newStr.indexOf(arr[i+1]); newArr[i] = newStr.slice(a,b);*/ &#125; if(/[a-zA-z]/.test(newArr[0]))&#123; newStr = newArr.join('').toLowerCase(); &#125;else&#123; newArr.shift(); newStr = newArr.join('').toLowerCase(); &#125; // 如果首字母也为大写，那么需要进行判断来删除首字母前面添加的'-' return newStr; &#125;&#125;spinalCase("The_Andy_Griffith_Show"); Sum All Odd Fibonacci Numbers给一个正整数num，返回小于或等于num的斐波纳契奇数之和。斐波纳契数列中的前几个数字是 1、1、2、3、5 和 8，随后的每一个数字都是前两个数字之和。例如，sumFibs(4)应该返回 5，因为斐波纳契数列中所有小于4的奇数是 1、1、3。 提示：此题不能用递归来实现斐波纳契数列。因为当num较大时，内存会溢出，推荐用数组来实现。12345678910111213141516171819var sumFibs = function() &#123; var cache = [1,1]; return function(num)&#123; if(num&gt;=cache.length)&#123; for(var i= cache.length;i&lt;num;i++)&#123; cache[i] = cache[ i-2 ] + cache [i - 1]; &#125; &#125; var arr = cache.filter(function(ele)&#123; return ele%2 !== 0&amp;&amp;ele &lt;= num; &#125;); return arr.reduce(function(a,b)&#123; return a+b; &#125;); &#125;;&#125;();sumFibs(4); Sum All Primes求小于等于给定数值的质数之和。 只有 1 和它本身两个约数的数叫质数。例如，2 是质数，因为它只能被 1 和 2 整除。1 不是质数，因为它只能被自身整除。 给定的数不一定是质数。 首先需要了解求质数的算法，比较受推荐有两种。 首先尝试2，然后尝试只要尝试小于√x 的质数（因数的成对出现）； 筛法。首先，2是公认最小的质数，所以，先把所有2的倍数去掉；然后剩下的那些大于2的数里面，最小的是3，所以3也是质数；然后把所有3的倍数都去掉，剩下的那些大于3的数里面，最小的是5，所以5也是质数…… 刚开始的思路是，创建一个0-n的数组，对数组的value进行筛选,但是这样性能很差，数组内每个数字占内存较大，想到创建一个n的数组，获取索引值并判断，将布尔值存入数组索引位置，最后在获得索引值index，相加即可。 12345678910111213141516171819202122232425function sumPrimes(num) &#123; var newArr = Array(num+1).fill(true); newArr[0] = newArr[1] = false; for(i=2;i&lt;= Math.sqrt(num);i++)&#123; if(newArr[i])&#123; for(j=i;j*i&lt;= num;j++)&#123; newArr[j*i] = false; &#125; &#125; &#125; var resArr = []; for(x =0;x&lt; newArr.length;x++)&#123; resArr.push(newArr.indexOf(true,x)); &#125; resArr = Array.from(new Set(resArr)).filter(function(val)&#123; return val&gt;0; &#125;); return resArr.reduce(function(a,b)&#123; return a + b; &#125;);&#125;sumPrimes(10); Smallest Common Multiple最小公倍数 在此之前要了解欧拉算法求最大公约数。简单的说，求两个数的最大公约数，用大数对小数求模，如果能被整除，则小数是这两个数的最大公约数。如果不能整除，就用小数对余数再次求模，循环此过程直到返回能除尽的那个除数。就是最大公约数。比如20和15，用20除以15余数为5，然后用15除以余数5，能够整除，所以返回出来的除数5为这两个数的最大公约数。 有了最大公约数，就可以求最小公倍数。最小公倍数的求法是：彼此之间的乘积除以最大公约数。 因为是求几个连续自然数之间的公倍数，所以，求出前两个最小公倍数之后，用这个最小公倍数和下一个值比较。然后就得出了新的最小公倍数。主要用的是递归的思想。 12345678910111213141516171819202122function smallestCommons(arr) &#123; var resArr = []; arr = arr.sort(function(pre,next)&#123; return next-pre; &#125;); var max = function(m,n)&#123; if(m%n === 0)&#123; return n; &#125;else&#123; return max(n,m%n); &#125; &#125;; var num = arr[1]; for(var i = arr[1]+1;i&lt;=arr[0];i++)&#123; num *=i/max(num,i); &#125; return num;&#125;smallestCommons([1,13]); Finders Keepers12345678910111213141516function find(arr, func) &#123; var num = 0; for(i=0;i&lt;arr.length;i++)&#123; if(func(arr[i]))&#123; num = arr[i]; break; &#125; &#125; if (num === 0)&#123; return undefined; &#125; return num;&#125;find([1, 3, 5, 8, 9, 10], function(num)&#123; return num % 2 === 0; &#125;); Drop it让我们来丢弃数组(arr)的元素，从左边开始，直到回调函数return true就停止。 第二个参数，func，是一个函数。用来测试数组的第一个元素，如果返回fasle，就从数组中抛出该元素(注意：此时数组已被改变)，继续测试数组的第一个元素，如果返回fasle，继续抛出，直到返回true。 最后返回数组的剩余部分，如果没有剩余，就返回一个空数组。 我的思路是先先通过filter遍历后获得同伙函数的值，将遍历后数组的第一个元素与传入的arr数组进行indexOf索引匹配，然后用silce()分割即可，这里要注意，如果遍历后所得数组为空，需要做判断。 123456789101112131415function drop(arr, func) &#123; var newArr = arguments[0];// Drop them elements. newArr = newArr.filter(function(val)&#123; return func(val); &#125;); if(newArr.length!== 0)&#123; arr = arr.slice(arr.indexOf(newArr[0])); &#125; else&#123; arr = []; &#125; return arr;&#125;drop([1, 2, 3, 4], function(n) &#123;return n &gt; 5;&#125;); Steamroller对嵌套的数组进行扁平化处理。你必须考虑到不同层级的嵌套。如果只在外面声明一个全局的新数组，那么无法得出新数组，而在函数内声明，则需要使用闭包。 12345678910111213141516function steamroller(arr) &#123; var result = []; function steam(ifarr)&#123; if(Array.isArray(ifarr))&#123; return ifarr.forEach(function(val)&#123; return steam(val); &#125;); &#125;else&#123; result.push(ifarr); &#125; &#125; steam(arr); return result;&#125;steamroller([1, [2], [3, [[4]]]]); Binary Agents传入二进制字符串，翻译成英语句子并返回。 二进制字符串是以空格分隔的。parseInt转换进制，map遍历数组 123456789function binaryAgent(str) &#123; var newArr = str.split(' '); newArr = newArr.map(function(val)&#123; return String.fromCharCode(parseInt(val,2)); &#125;); return newArr.join('');&#125;binaryAgent("01000001 01110010 01100101 01101110 00100111 01110100 00100000 01100010 01101111 01101110 01100110 01101001 01110010 01100101 01110011 00100000 01100110 01110101 01101110 00100001 00111111"); Everything Be True完善编辑器中的every函数，如果集合(collection)中的所有对象都存在对应的属性(pre)，并且属性(pre)对应的值为真。函数返回ture。反之，返回false。 123456789101112function every(collection, pre) &#123; var counter = 0;// Create a counter to check how many are true. for(var i in collection)&#123; // Check for each object if(collection[i].hasOwnProperty(pre) &amp;&amp; Boolean(collection[i][pre]))&#123; counter++; &#125; // If it is has property and value is truthy &#125; return counter == collection.length;&#125;// Outside the loop, check to see if we got true for all of them and return true or falseevery([&#123;"user": "Tinky-Winky", "sex": "male"&#125;, &#123;"user": "Dipsy", "sex": "male"&#125;, &#123;"user": "Laa-Laa", "sex": "female"&#125;, &#123;"user": "Po", "sex": "female"&#125;], "sex"); Arguments Optional创建一个计算两个参数之和的 function。如果只有一个参数，则返回一个 function，该 function 请求一个参数然后返回求和的结果。 例如，add(2, 3) 应该返回 5，而 add(2) 应该返回一个 function。 调用这个有一个参数的返回的 function，返回求和的结果： var sumTwoAnd = add(2); sumTwoAnd(3) 返回 5。 如果两个参数都不是有效的数字，则返回 undefined。 12345678910111213141516171819function add() &#123; if(typeof arguments[0] !== 'number' || (arguments.length&gt;1 &amp;&amp; typeof arguments[1] !== 'number'))&#123; return undefined; &#125; if(arguments.length!=2)&#123; var newArg = arguments[0]; return function(num)&#123; if(typeof num !== 'number')&#123; return undefined; &#125;else&#123; return newArg + num; &#125; &#125;; &#125;else&#123; return arguments[0]+arguments[1]; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HTML中的增强型表单标签]]></title>
      <url>%2F2017%2F03%2F27%2Fh5-newTitle-01%2F</url>
      <content type="text"><![CDATA[一、增型表单标签HTML5中，新标准把文本框提示信息、表单校验、日期选择控件、颜色选择控件、范围控件、进度条、标签跨表单等功能直接加入新的表单标签中。 但在众多现代浏览器中，最新版本的Opera浏览器对新型表单的支持才最为完美。 1. Number类型input标签1&lt;input type="number" name="demoNumber" min="1" max="100" step="1"/&gt; name: 标识表单提交时的key值 min: 标识当前输入框输入的最小值 max: 标识当前输入框输入的最大值 step: 标识点击增大/减小的时候，增加/减小的步长 2. Email类型input标签1&lt;input type="email" name="email" placeholder="请输入注册邮箱"/&gt; 当表单在提交前，此文本框会自动校验是否符合邮箱的正则表达式。 3. URL类型的input标签1&lt;input type="url" placeholder="请输入网址" name="url"/&gt; 4. Tel类型的input标签1&lt;input type="tel" placeholder="输入电话" name="phone"/&gt; 5. range类型的input标签1&lt;input type="range" min="0" max="50" step="5" name="rangedemo" value="0"/&gt; 此类型标签的加入，输入范围内的数据变得非常简单容易，而且非常标准，用户输入可感知体验非常好。另外此标签可以跟表单新增加的output标签一块使用，达到一个联动的效果。1234&lt;form oninput="output.value=parseInt(range.value)"/&gt; &lt;input type="range" min="0" max="100" step="5" name="range" value="0"/&gt; &lt;output name="output"&gt;0&lt;output/&gt;&lt;/form&gt; 6. 新的日期、时间、月份、星期input标签Web项目开发，一定会遇到相关的js日期控件，在HTML5中新加入的表单属性将会使Web开发变得更加简洁。1&lt;input type="date" name="datedemo"/&gt; 相关的日期属性还包括：month、time、week、datetime-local、datetime 7. 颜色选择input标签1&lt;input type=&quot;color&quot; name=&quot;colordemo&quot;/&gt; 8. input标签自动完成功能有的项目会要求实现自动完成或者输入提示功能，在HTML5的支持下将变得简单。 123456&lt;input type="text" autocomplete="on" name="demoAutoComplete" list="autoNames" /&gt;&lt;datalist id="autoNames"&gt; &lt;option value="实验楼" &gt;&lt;/option&gt; &lt;option value="HTML5" &gt;&lt;/option&gt; &lt;option value="input标签" &gt;&lt;/option&gt;&lt;/datalist&gt; 二、HTML5表单新属性1. input表单新增加的特有属性autofocus 属性，demo:1&lt;input type="text" autofocus="autofocus"/&gt; 此属性可以设置当前页面中input标签加载完毕后获得焦点。 max、min、step：这些上面介绍过，都是跟数字相关。 placeholder：提示信息属性。 multiple：用于文件上传控件，设置此属性后，允许多个文件。 校验属性：设置了required属性后预示着当前文本框在提交前必须有数据输入，而这一切都是由浏览器自动完成。还添加了pattern正则表达式校验：1&lt;input type="text" autofocus="autofocus" required pattern="\d+"/&gt; 另外一个较大的改进就是增加了form属性，也就是说，任何一个标签都可以指定它所属于一个表单，而不是必须在 中进行包裹了。1&lt;input type="text" form="demoform" name="demo"/&gt; 2. form表单新增加的属性 novalidate属性规定在提交表单时不应该验证 form 或input域 autocomplete属性规定form或input域应该拥有自动完成功能 1&lt;form action="" method="POST" novalidate="true"&gt;&lt;/form&gt; 三、综合实例12345678910111213141516171819&lt;fieldset&gt; &lt;legend&gt;表单演示：最新Opera浏览器支持效果良好&lt;/legend&gt; &lt;form action="" method="POST" id="form1" oninput="output.value=parseInt(range.value)"&gt; &lt;input type="text" autofocus="autofocus" required pattern="\d+" name="auto" placeholder="必填项测试" /&gt; &lt;input type="number" name="demoNumber" min="1" max="100" step="2" /&gt; &lt;input type="email" placeholder="请输入邮箱" name="mail" /&gt; &lt;input type="url" name="url" placeholder="输入正确的网址" /&gt; &lt;br /&gt; 日期：&lt;input type="datetime" name="time" /&gt; 颜色：&lt;input type="color" name="color" /&gt;&lt;br /&gt; &lt;br /&gt; &lt;input type="range" min="0" max="50" step="5" name="range" value="0" /&gt; &lt;output name="output"&gt;0&lt;/output&gt; &lt;br /&gt; &lt;input type="submit" value="提交表单" /&gt; &lt;/form&gt; 表单外的input标签： &lt;input type="text" form="form1" name="demo" /&gt;&lt;/fieldset&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[关于Canvas的一些参数]]></title>
      <url>%2F2017%2F03%2F27%2Fcanvas-property%2F</url>
      <content type="text"><![CDATA[一、Canvas Canvas就是一个画布，可以进行画任何的线、图形、填充等一系列的操作，而且操作的画图就是js，所以让js编程到了嗑药的地步。另外Canvas不仅仅提供简单的二维矢量绘图，也提供了三维的绘图，以及图片处理等一系列的api支持。 二、Canvas中的Context 要使用Canvas来绘制图形必须在页面中添加Canvas的标签12345&lt;canvas id="demoCanvas" width="500" height="500"&gt;&lt;p&gt; 请使用支持HTML5的浏览器查看本实例&lt;/p&gt;&lt;/canvas&gt; 只有上面的标签，只能是创建好了一个画布，其中width 和height 属性就是设置画布的大小。Id属性也是必须的，后面要用Id来拿到当前的 Canvas 的Dom对象。通过此 Canvase 的Dom对象就可以获取他的上下文 （Context） 了， Canvas 绘制图形都是靠着 Canvas 对象的上下文对象 123456&lt;script type="text/javascript"&gt;//第一步：获取canvas元素var canvasDom = document.getElementById("demoCanvas");//第二步：获取上下文var context = canvasDom.getContext('2d');&lt;/script&gt; Context上下文默认两种绘制方式： 第一种：绘制线（stroke） 第二种：填充（fill） 三、Canvas绘制立体透明矩形 1. Canvas绘制步骤： 创建HTML页面，设置画布标签 编写js，获取画布dom对象 通过canvas标签的Dom对象获取上下文 设置绘制样式、颜色 绘制矩形，或者填充矩形 12345678910111213141516171819&lt;body&gt; &lt;canvas id="demoCanvas" width="500" height="500"&gt; &lt;p&gt;请使用支持HTML5的浏览器查看本实例&lt;/p&gt; &lt;/canvas&gt; &lt;!---下面将演示一种绘制矩形的demo---&gt; &lt;script type="text/javascript"&gt; //第一步：获取canvas元素 var canvasDom = document.getElementById("demoCanvas"); //第二步：获取上下文 var context = canvasDom.getContext('2d'); //第三步：指定绘制线样式、颜色 context.strokeStyle = "red"; //第四步：绘制矩形，只有线。内容是空的 context.strokeRect(10, 10, 190, 100); //以下演示填充矩形。 context.fillStyle = "blue"; context.fillRect(110,110,100,100); &lt;/script&gt;&lt;/body&gt; 四、Canvas绘制线条 Context 对象的 beginPath 方法表示开始绘制路径，moveTo(x, y)方法设置线段的起点，lineTo(x, y)方法设置线段的终点，stroke方法用来给透明的线段着色。moveto和lineto方法可以多次使用。最后，还可以使用closePath方法，自动绘制一条当前点到起点的直线，形成一个封闭图形，省却使用一次lineto方法。123456789101112131415161718&lt;body&gt; &lt;canvas id="demoCanvas" width="500" height="600"&gt; &lt;/canvas&gt; &lt;script type="text/javascript"&gt; //通过id获得当前的Canvas对象 var canvasDom = document.getElementById("demoCanvas"); //通过Canvas Dom对象获取Context的对象 var context = canvasDom.getContext("2d"); context.beginPath(); // 开始路径绘制 context.moveTo(20, 20); // 设置路径起点，坐标为(20,20) context.lineTo(200, 200); // 绘制一条到(200,20)的直线 context.lineTo(400, 20); context.closePath(); context.lineWidth = 2.0; // 设置线宽 context.strokeStyle = "#CC0000"; // 设置线的颜色 context.stroke(); // 进行线的着色，这时整条线才变得可见 &lt;/script&gt;&lt;/body&gt; 五、Canvas绘制文本 Context上下文对象的fillText(string, x, y)方法是用来绘制文本，它的三个参数分别为文本内容、起点的x坐标、y坐标。使用之前，需用font设置字体、大小、样式（写法类似与CSS的font属性）。与此类似的还有strokeText方法，用来添加空心字。 另外注意一点：fillText方法不支持文本断行，即所有文本出现在一行内。所以，如果要生成多行文本，只有调用多次fillText方法。 123456789101112131415161718&lt;canvas id="demoCanvas" width="500" height="600"&gt;&lt;/canvas&gt;&lt;script type="text/javascript"&gt; //通过id获得当前的Canvas对象 var canvasDom = document.getElementById("demoCanvas"); //通过Canvas Dom对象获取Context的对象 var context = canvasDom.getContext("2d"); context.moveTo(200,200); // 设置字体 context.font = "Bold 50px Arial"; // 设置对齐方式 context.textAlign = "left"; // 设置填充颜色 context.fillStyle = "#005600"; // 设置字体内容，以及在画布上的位置 context.fillText("老马!", 10, 50); // 绘制空心字 context.strokeText("blog.itjeek.com!", 10, 100);&lt;/script&gt; 六、Canvas绘制圆形和椭圆 Context上下文的arc方法就是绘制圆形或者椭圆，arc方法的x和y参数是圆心坐标，radius是半径，startAngle和endAngle则是扇形的起始角度和终止角度（以弧度表示），anticlockwise表示做图时应该逆时针画（true）还是顺时针画（false）。 12345678910111213&lt;canvas id="demoCanvas" width="500" height="600"&gt;&lt;/canvas&gt;&lt;script type="text/javascript"&gt; //通过id获得当前的Canvas对象 var canvasDom = document.getElementById("demoCanvas"); //通过Canvas Dom对象获取Context的对象 var context = canvasDom.getContext("2d"); context.beginPath();//开始绘制路径 //绘制以 （60,60）为圆心，50为半径长度，从0度到360度（PI是180度），最后一个参数代表顺时针旋转。 context.arc(60, 60, 50, 0, Math.PI * 2, true); context.lineWidth = 2.0;//线的宽度 context.strokeStyle = "#000";//线的样式 context.stroke();//绘制空心的，当然如果使用fill那就是填充了。&lt;/script&gt; 七、Canvas绘制图片 Canvas绘制图片应该是他的一大特点或者是亮点吧。当然配合File的API，让JS变得无可匹敌。那接下里给大家演示一下怎样绘制图片，并且做出一个立体效果出来。123456789101112131415&lt;canvas id="demoCanvas" width="500" height="600"&gt;&lt;/canvas&gt;&lt;script type="text/javascript"&gt; //通过id获得当前的Canvas对象 var canvasDom = document.getElementById("demoCanvas"); //通过Canvas Dom对象获取Context的对象 var context = canvasDom.getContext("2d"); var image = new Image();//创建一张图片 image.src = "Images/a.png";//设置图片的路径 image.onload = function() &#123;//当图片加载完成后 for (var i = 0; i &lt; 10; i++) &#123;//输出10张照片 //参数：（1）绘制的图片 （2）坐标x，（3）坐标y context.drawImage(image, 100 + i * 80, 100 + i * 80); &#125; &#125;;&lt;/script&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HTML5中的新结构标签]]></title>
      <url>%2F2017%2F03%2F27%2Fh5-newTitle%2F</url>
      <content type="text"><![CDATA[示例图 传统 HTML5 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;my page&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;header&gt;header&lt;/header&gt; &lt;nav&gt;nav&lt;/nav&gt; &lt;article&gt; &lt;section&gt;section&lt;/section&gt; &lt;/article&gt; &lt;aside&gt;aside&lt;/aside&gt; &lt;footer&gt;footer&lt;/footer&gt; &lt;/body&gt;&lt;/html&gt; section定义文档中的节。它用来表现普通的文档内容或应用区块。但section元素标签并非一个普通的容器元素，它表示一段专题性的内容，一般会带有标题。 123456789&lt;section&gt; &lt;h1&gt;section是什么？&lt;/h1&gt; &lt;h2&gt;一个新章节&lt;/h2&gt; &lt;article&gt; &lt;h2&gt;关于section&lt;/h2&gt; &lt;p&gt;section的介绍&lt;/p&gt; ... &lt;/article&gt;&lt;/section&gt; article特殊的 section 标签，它比 section 具有更明确的语义，它代表一个独立的、完整的相关内容块。当我们描述一件具体的事物的时候，通常鼓励使用 article 来代替 section 。 article 会有标题部分（通常包含在header内），也可以包含 footer。 article 可以嵌套，内层的 article 对外层的 article 标签有隶属关系。 12345678910&lt;article&gt; &lt;header&gt; &lt;hgroup&gt; &lt;h1&gt;这是一篇介绍HTML 5结构标签的文章&lt;/h1&gt; &lt;h2&gt;HTML 5的革新&lt;/h2&gt; &lt;/hgroup&gt; &lt;time datetime="2011-03-20"&gt;2011.03.20&lt;/time&gt; &lt;/header&gt; &lt;p&gt;文章内容详情&lt;/p&gt;&lt;/article&gt; nav可以作为页面导航的链接组，其中的导航元素链接到其它页面或者当前页面的其他部分，是html代码在语义化方面更加精确，同事对于屏幕阅读器等设备的支持也更好。 1234567&lt;nav&gt; &lt;ul&gt; &lt;li&gt;厚德IT&lt;/li&gt; &lt;li&gt;FlyDragon&lt;/li&gt; &lt;li&gt;J飞龙天惊&lt;/li&gt; &lt;/ul&gt;&lt;/nav&gt; asideaside 标签用来装载非正文的内容，被视为页面里面一个单独的部分。它包含的内容与页面的主要内容是分开的，可以被删除，而不会影响到网页的内容、章节或是页面传达的信息。例如广告，成组的链接，侧边栏等等。 1234&lt;aside&gt; &lt;h1&gt;作者简介&lt;/h1&gt; &lt;p&gt;厚德IT&lt;/p&gt;&lt;/aside&gt; headerheader 标签定义文档的页眉，通常是一些引导和导航信息。它不局限于写在网页的头部，也可以写在网页的内容里面。 通常header 标签至少包含一个标记（h1 - h6 ），还可以包括hgroup 标签，还可以包括表格内容、标识、搜索表单、nav 导航等。 123456&lt;header&gt; &lt;hgroup&gt; &lt;h1&gt;网站标题&lt;/h1&gt; &lt;h1&gt;网站副标题&lt;/h1&gt; &lt;/hgroup&gt;&lt;/header&gt; footerfooter 标签定义section 或document 的页脚，包含了与页面、文章或是部分内容有关的信息，比如说文章的作者或者日期。它和header 标签使用基本一样，可以在一个页面中多次使用，如果在一个区段的后面加入footer ，那么它就相当于该区段的页脚了。123456&lt;header&gt; &lt;hgroup&gt; &lt;h1&gt;网站标题&lt;/h1&gt; &lt;h1&gt;网站副标题&lt;/h1&gt; &lt;/hgroup&gt;&lt;/header&gt; hgrouphgroup 标签是对网页或区段section 的标题元素（h1 - h6 ）进行组合。例如，在一区段中你又连续的h系列的标签元素，则可以用hgroup 将他们括起来。1234&lt;hgroup&gt; &lt;h1&gt;这是一篇介绍HTML 5结构标签的文章&lt;/h1&gt; &lt;h2&gt;HTML 5的革新&lt;/h2&gt;&lt;/hgroup&gt; fivure用于对元素进行组合。多用于图片于图片描述组合。 1234&lt;figure&gt; &lt;img src="img.gif" alt="figure标签" title="figure标签" /&gt; &lt;figcaption&gt;这儿是图片的描述信息&lt;/figcaption&gt;&lt;/figure&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Ajax学习小记-概念]]></title>
      <url>%2F2017%2F03%2F27%2Fajax-note%2F</url>
      <content type="text"><![CDATA[异步通过 XMLHttpRequest 函数来实现客户端和服务器端的异步处理 具体实现： 运用HTML和CSS来实现页面，表达信息； 运用XMLHttpRequest和Web服务器进行数据的异步交换； 运用JavaScript操作DOM，实现动态局部刷新； XMLHttpREquest对象 不兼容IE6123456var request;if (window.XMLHttpRequest) &#123; request = new XMLHttprequest();//IE7+,chrome,ff,safari.&#125; else &#123; request = new ActiveXobject('Microsoft.XmlHTTP');??&#125; HTTP请求HTTP请求过程 建立TCP连接 Web浏览器向Web服务器发送请求命令 Web浏览器发送请求头信息 Web服务器应答 Web服务器发送应答头信息 Web服务器向浏览器发送数据 Web服务器关闭TCP连接 HTTP组成部分 HTTP请求的方法或动作，比如是GET还是POST请求 正在请求的URL 请求头（如客户端环境信息，身份验证信息） 请求体，也就是请求 正文，请求好着呢个文中可以包含客户提交的 查询字符串信息，表单信息等等。 重点概念 GET： 一般用信息获取 使用URL传递参数 对所发送信息的数量也有 POST： 一半用于修改服务器上的资源 对所发送的信息数量无限制 响应组成： 数字文字的状态码，显示请求的成功和失败 响应头 响应体 HTTP状态码 1XX：信息类，表示收到浏览器请求，正在处理 2XX: 成功，正确接受 3XX：重定向，请求失败 4XX：客户端错误，如 404 NOT 5XX：服务器错误，如 500 XMLHttpRequest发送请求： open(method,url,async) method：规定HTTP发送请求的方式是get还是post,不区分大小写，一般来说用大写 url：请求地址(相对地址或绝对地址) async:同步/异步(false/true)，默认是异步也就是true，可以不用填写 send(string): 发送到服务器（该参数可以填或者不填—–get方法不填或填null，post:一般要填） XMLHttpRequest取得响应 responseText:获得字符串形式的响应数据 responseXML：获得XML形式的响应数据（比较少） status和statusText:以数字和文本形式返回HTTP状态码 getAllResponseHeader()：获取所有的响应报头 getResponseHeader()：查询响应中的某个字段的值 readyState属性的变化代表服务器响应的变化 请求未初始化，open还没有调用 服务器连接已建立，open已经调用了 请求已接收，也就是接收到头信息了 请求处理中，也就是接收到了响应主体 请求已完成，且响应已就绪，也就是响应完成了]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[慕课网-人机大战五子棋AI篇学习笔记]]></title>
      <url>%2F2017%2F03%2F27%2Fgo-bang%2F</url>
      <content type="text"><![CDATA[创建赢法数组 先贴出第一步代码 1234567var wins = [];for(let i=0 ; i &lt; 15 ; i++ ) &#123; wins[i] = []; for(let j = 0; j&lt;15; j++) &#123; wins[i][j] = []; &#125;&#125; 这段代码仅仅只是创了一个准备用于记录所有赢法的三维空数组。 接下来第二部就是建立赢法数组，复制并建立索引。代码：竖排123456789var count = 0;for(let i=0; i&lt; 15 ;i++) &#123; for(let j=0;j&lt;11 ;j++) &#123; for(let k=0;k&lt;5;k++) &#123; wins[i][j+k][count] = true; &#125; count++; &#125;&#125; 本段代码的含义就是遍历了所有竖排列中存在的赢的组合，count为每一种赢法所对应的唯一索引。例如：12345wins[0][0][0] = true;wins[0][1][0] = true;wins[0][2][0] = true;wins[0][3][0] = true;wins[0][4][0] = true; 就是意味着我们将第一竖排前五个空格连成一线的赢法都列举出来，并给每一个格子赋值为true、给出的索引为count = 0（即第三维数组）。 同理，很容易可以写出遍历横排，45°角和135°角排列上的代码： 横排12345678910var count = 0;for(let i=0; i&lt; 15 ;i++) &#123; for(let j=0;j&lt;11 ;j++) &#123; for(let k=0;k&lt;5;k++) &#123; wins[j+k][i][count] = true; &#125; count++; &#125;&#125; 45°12345678910var count = 0;for(let i=0; i&lt; 11 ;i++) &#123; for(let j=0;j&lt;11 ;j++) &#123; for(let k=0;k&lt;5;k++) &#123; wins[i+k][j+k][count] = true; &#125; count++; &#125;&#125; 135°12345678910var count = 0;for(let i=0; i&lt; 11 ;i++) &#123; for(let j=14;j&gt;3 ;j++) &#123; for(let k=0;k&lt;5;k++) &#123; wins[i+k][j-k][count] = true; &#125; count++; &#125;&#125; 相较于较为抽象的描述，还是图来的简单明了。 输赢判断慕课网将其称为赢法统计，我总觉得过于抽象了。让我来理解，说是输赢判断，或者说是迈向胜利的进度，更加容易理解。代码：1234567var myWin = [];//我方胜利进度（黑子）var coumputerWin = [];//电脑方胜利进度(白子)for(let i = 0;i &lt; count ; i++) &#123; myWin[i] = 0; coumputerWin[i] = 0;&#125; 首相遍历count，两方胜利进度数组都赋值为0。 然后就要修改落子时的onclick事件的判定条件。12345678910111213141516171819202122232425262728293031var over = false;//判断棋局是否结束chess.onclick = function(e) &#123; if(over) &#123; return; &#125; var x = e.offsetX; var y = e.offsetY; var i= Math.floor(x/30); var j = Math.floor(y/30); if(hascheer[i][j] == 0) &#123; oneStep(i,j,me); if(me) &#123; hascheer[i][j] = 1; &#125;else &#123; hascheer[i][j] = 2; &#125; me = !me; //本次操作添加代码 for(let k= 0;k&lt;count; k++) &#123; if(wins[i][j][k]) &#123; myWin[k] ++; pcWin = 6;//当有一方占据了当前赢法数组中的一格，即可判定为另一方在该赢法数组条件下已不可能获胜，抛出异常数值。 if(myWin[k] == 5) &#123; window.alert(&quot;你赢了!&quot;); &#125; &#125; &#125; &#125;&#125; 前面的代码是UI篇当中的。关于输赢判断，思路是在onclick事件下，每次落子，遍历count,并对落子坐标i,j所对应的赢法k胜利进度+1，胜利进度=5的时候，就代表在这一赢法下获胜了。 例如，在wins[0][0][k]的情况下，其实只有三种赢法，即向右五格，向下五格以及45°角五格，因此，当k不等于这三种赢法的索引时，myWins[k]就不会自加，即该赢法进度没有变化。PS：后面要做computer自动下子，所以这里只写了黑子的判定。 AI实现代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100var pcAI = function() &#123; //玩家分数 let myScore = [],// 电脑分数 pcScore = [],// 最优位置的分数 max = 0,// 电脑预落子maxI列 maxI = 0,// 电脑预落子maxJ行 maxJ =0; for (let i=0;i&lt;15;i++) &#123; myScore[i] = []; pcScore[i] = []; for(let j=0; j&lt;15;j++) &#123; myScore[i][j] = 0; pcScore[i][j] = 0; &#125; &#125;// 对两个数组分别进行加分 for (let i=0;i&lt;15;i++) &#123; for(let j=0;j&lt;15;j++) &#123; if(hasChess[i][j] == 0) &#123; for (let k=0;k&lt;count;k++)&#123; if(wins[i][j][k]) &#123; switch(myWin[k]) &#123; case 1: myScore[i][j] +=200; break; case 2: myScore[i][j] +=400; break; case 3: myScore[i][j] +=2000; break; case 4: myScore[i][j] +=10000; break; default: break; &#125; switch(pcWin[k]) &#123; case 1: pcScore[i][j] +=220; break; case 2: pcScore[i][j] +=420; break; case 3: pcScore[i][j] +=2220; break; case 4: pcScore[i][j] +=20000; break; case 6: pcScore[i][j] = 0; break; default: break; &#125; &#125; &#125;// 若玩家在(i,j)处的分数高于目前的最高分数,则落子在(i,j)处 if(myScore[i][j] &gt; max) &#123; max = myScore[i][j]; maxI = i; maxJ = j; &#125;else if(myScore[i][j] == max&amp;&amp; pcScore[i][j] &gt; pcScore[maxI][maxJ])&#123; // 如果玩家(i,j)处和目前最优分数一样大，则比较电脑在该位置和预落子的位置的分数 maxI = i; maxJ = j; &#125;// 如果电脑(i,j)处比目前最优的分数大，则落子在(i,j)处 if(pcScore[i][j] &gt; max) &#123; max = pcScore[i][j]; maxI = i; maxJ = j; &#125;else if(pcScore[i][j] == max &amp;&amp; myScore[i][j] &gt; myScore[maxI][maxJ])&#123;// 如果电脑(i,j)处和目前最优分数一样大，则比较玩家在该位置和预落子的位置的分数 maxI = i; maxJ = j; &#125; &#125; &#125;; &#125; oneStep(maxI,maxJ,false); hasChess[maxI][maxJ] = 2; for (let n=0 ; n&lt;count;n++) &#123; if(wins[maxI][maxJ][n]) &#123; pcWin[n]++; myWin[n] =6; if(pcWin[n] == 5) &#123; window.alert("你输了！"); over = true; &#125; &#125; &#125;&#125; 很复杂的代码。通过遍历坐标，确定包含这个坐标的赢法，然后对这个赢法进行权重加成，赢法内拥有越多的黑子，权重越大。同时，对自己下子的每个坐标所对应的的赢法也进行加权，并且电脑获胜是的权重是高于人的。（这里很难用自己的话描述出来）。以图为例： 当黑子落点为坐标[0][0]时，此时应当是有三个方向上，即横、竖、45°，三个赢法数组存在。并且所对应的元素均为true。黑子落点后，上面代码中的第一次循环因为if(hasCheer[0][0])为false，跳过，三种赢法内空余的格子都进入循环，每种myWin[k]都是一，所以横、竖、45°线上其他空格的分数均为200，因此第一次循环获取到坐标i=0,j=之后，后面的因为都与它相等不会获得更高权重，所以AI会落子在0,1处。 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231//canvasvar gobang = document.getElementById("gobang"), context = gobang.getContext("2d"), background = new Image(); background.src = "img/bg.png";context.strokeStyle = "#000";background.onload = function() &#123; context.drawImage(background,0,0,450,450); (() =&gt; &#123; for (let i= 0; i&lt;15 ; i++ ) &#123; context.moveTo(15 + i*30, 15); context.lineTo(15 + i*30, 435); context.stroke(); context.moveTo(15,15 + i*30); context.lineTo(435,15+ i*30); context.stroke(); &#125; &#125;)();&#125;//落子var hasChess = [], me = true;for (let i=0; i&lt;15; i++) &#123; hasChess[i] = []; for (let j=0; j&lt;15;j++) &#123; hasChess[i][j] = 0; &#125;&#125;var oneStep = function (i,j,me) &#123; context.beginPath(); context.arc(15 + i*30,15 + j*30,13,0,2*Math.PI); context.closePath(); let gradient = context.createRadialGradient(15 + i*30, 15+ j*30 -2,50,15 + i*30 +2, 15+j * 30 - 2,0); me ? (()=&gt;&#123;gradient.addColorStop(0,"#0a0a0a");gradient.addColorStop(1,"#8e8e8e" )&#125;)() : (()=&gt;&#123;gradient.addColorStop(0,"#8e8e8e");gradient.addColorStop(1,"#fff")&#125;)(); context.fillStyle = gradient; context.fill(); me = !me;&#125;//赢法数组var wins = [], count = 0; //生产赢法数组for (let i=0;i&lt;15 ; i ++) &#123; wins[i] = []; for(let j = 0; j&lt;15;j ++) &#123; wins[i][j] = []; &#125;&#125;//所有竖排赢法for (let i=0; i&lt;15; i++) &#123; for(let j=0;j&lt;11;j++) &#123; for (let k=0;k&lt;5;k++) &#123; wins[i][j+k][count] = true; &#125; count++; &#125;&#125;//所有横排赢法for (let i=0; i&lt;15;i++) &#123; for (let j = 0;j&lt;11;j ++) &#123; for (let k=0;k&lt;5;k++) &#123; wins[j+k][i][count] = true; &#125; count++; &#125;&#125;//所有45°赢法for (let i=0;i&lt;11;i++) &#123; for(let j=0;j&lt;11;j++) &#123; for(let k=0;k&lt;5;k++) &#123; wins[i+k][j+k][count] = true; &#125; count++; &#125;&#125;//所有135°赢法for (let i=0; i&lt;11;i++) &#123; for(let j=14;j&gt;3;j--) &#123; for (let k=0;k&lt;5;k++) &#123; wins[i+k][j-k][count] = true; &#125; count++; &#125;&#125;//输赢判断var myWin = [], pcWin = [], over = false;for(let i=0;i&lt;count ;i++) &#123; myWin[i] = 0; pcWin[i] = 0;&#125;//AI实现var pcAI = function() &#123; //玩家分数 let myScore = [],// 电脑分数 pcScore = [],// 最优位置的分数 max = 0,// 电脑预落子maxI列 maxI = 0,// 电脑预落子maxJ行 maxJ =0; for (let i=0;i&lt;15;i++) &#123; myScore[i] = []; pcScore[i] = []; for(let j=0; j&lt;15;j++) &#123; myScore[i][j] = 0; pcScore[i][j] = 0; &#125; &#125;// 对两个数组分别进行加分 for (let i=0;i&lt;15;i++) &#123; for(let j=0;j&lt;15;j++) &#123; if(hasChess[i][j] == 0) &#123; for (let k=0;k&lt;count;k++)&#123; if(wins[i][j][k]) &#123; switch(myWin[k]) &#123; case 1: myScore[i][j] +=200; break; case 2: myScore[i][j] +=400; break; case 3: myScore[i][j] +=2000; break; case 4: myScore[i][j] +=10000; break; default: break; &#125; switch(pcWin[k]) &#123; case 1: pcScore[i][j] +=220; break; case 2: pcScore[i][j] +=420; break; case 3: pcScore[i][j] +=2220; break; case 4: pcScore[i][j] +=20000; break; case 6: pcScore[i][j] = 0; break; default: break; &#125; &#125; &#125;// 若玩家在(i,j)处的分数高于目前的最高分数,则落子在(i,j)处 if(myScore[i][j] &gt; max) &#123; max = myScore[i][j]; maxI = i; maxJ = j; &#125;else if(myScore[i][j] == max&amp;&amp; pcScore[i][j] &gt; pcScore[maxI][maxJ])&#123; // 如果玩家(i,j)处和目前最优分数一样大，则比较电脑在该位置和预落子的位置的分数 maxI = i; maxJ = j; &#125;// 如果电脑(i,j)处比目前最优的分数大，则落子在(i,j)处 if(pcScore[i][j] &gt; max) &#123; max = pcScore[i][j]; maxI = i; maxJ = j; &#125;else if(pcScore[i][j] == max &amp;&amp; myScore[i][j] &gt; myScore[maxI][maxJ])&#123;// 如果电脑(i,j)处和目前最优分数一样大，则比较玩家在该位置和预落子的位置的分数 maxI = i; maxJ = j; &#125; &#125; &#125;; &#125; oneStep(maxI,maxJ,false); hasChess[maxI][maxJ] = 2; for (let n=0 ; n&lt;count;n++) &#123; if(wins[maxI][maxJ][n]) &#123; pcWin[n]++; myWin[n] =6; if(pcWin[n] == 5) &#123; window.alert("你输了！"); over = true; &#125; &#125; &#125;&#125;gobang.onclick = function(e) &#123; if (over) &#123; return; &#125; if (!me) &#123; return; &#125; let x = e.offsetX, y = e.offsetY, i = Math.floor(x/30), j = Math.floor(y/30); if (hasChess[i][j] == 0 ) &#123; oneStep(i,j,me); hasChess[i][j] = 1; for (let k=0; k&lt;count;k++) &#123; if(wins[i][j][k]) &#123; myWin[k]++; pcWin[k] =6; if(myWin[k] == 5) &#123; window.alert("你赢了！"); over = true; &#125; &#125; &#125; if(!over) &#123; pcAI(); &#125; &#125;&#125;]]></content>
    </entry>

    
  
  
</search>
